// Code generated by go-swagger; DO NOT EDIT.

package all

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new all API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for all API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateCertAuthority(params *CreateCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateCertAuthorityOK, error)

	CreateCertAuthorityOcspTLSTrustedCommonName(params *CreateCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateCertAuthorityOcspTLSTrustedCommonNameOK, error)

	CreateClientCertAuthority(params *CreateClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClientCertAuthorityOK, error)

	CreateClientCertAuthorityOcspTLSTrustedCommonName(params *CreateClientCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClientCertAuthorityOcspTLSTrustedCommonNameOK, error)

	CreateDmrCluster(params *CreateDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDmrClusterOK, error)

	CreateDmrClusterLink(params *CreateDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDmrClusterLinkOK, error)

	CreateDmrClusterLinkRemoteAddress(params *CreateDmrClusterLinkRemoteAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDmrClusterLinkRemoteAddressOK, error)

	CreateDmrClusterLinkTLSTrustedCommonName(params *CreateDmrClusterLinkTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDmrClusterLinkTLSTrustedCommonNameOK, error)

	CreateDomainCertAuthority(params *CreateDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDomainCertAuthorityOK, error)

	CreateMsgVpn(params *CreateMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnOK, error)

	CreateMsgVpnACLProfile(params *CreateMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileOK, error)

	CreateMsgVpnACLProfileClientConnectException(params *CreateMsgVpnACLProfileClientConnectExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileClientConnectExceptionOK, error)

	CreateMsgVpnACLProfilePublishException(params *CreateMsgVpnACLProfilePublishExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfilePublishExceptionOK, error)

	CreateMsgVpnACLProfilePublishTopicException(params *CreateMsgVpnACLProfilePublishTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfilePublishTopicExceptionOK, error)

	CreateMsgVpnACLProfileSubscribeException(params *CreateMsgVpnACLProfileSubscribeExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileSubscribeExceptionOK, error)

	CreateMsgVpnACLProfileSubscribeShareNameException(params *CreateMsgVpnACLProfileSubscribeShareNameExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileSubscribeShareNameExceptionOK, error)

	CreateMsgVpnACLProfileSubscribeTopicException(params *CreateMsgVpnACLProfileSubscribeTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileSubscribeTopicExceptionOK, error)

	CreateMsgVpnAuthenticationOauthProvider(params *CreateMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnAuthenticationOauthProviderOK, error)

	CreateMsgVpnAuthorizationGroup(params *CreateMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnAuthorizationGroupOK, error)

	CreateMsgVpnBridge(params *CreateMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnBridgeOK, error)

	CreateMsgVpnBridgeRemoteMsgVpn(params *CreateMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnBridgeRemoteMsgVpnOK, error)

	CreateMsgVpnBridgeRemoteSubscription(params *CreateMsgVpnBridgeRemoteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnBridgeRemoteSubscriptionOK, error)

	CreateMsgVpnBridgeTLSTrustedCommonName(params *CreateMsgVpnBridgeTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnBridgeTLSTrustedCommonNameOK, error)

	CreateMsgVpnClientProfile(params *CreateMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnClientProfileOK, error)

	CreateMsgVpnClientUsername(params *CreateMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnClientUsernameOK, error)

	CreateMsgVpnDistributedCache(params *CreateMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheOK, error)

	CreateMsgVpnDistributedCacheCluster(params *CreateMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterOK, error)

	CreateMsgVpnDistributedCacheClusterGlobalCachingHomeCluster(params *CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK, error)

	CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix(params *CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK, error)

	CreateMsgVpnDistributedCacheClusterInstance(params *CreateMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterInstanceOK, error)

	CreateMsgVpnDistributedCacheClusterTopic(params *CreateMsgVpnDistributedCacheClusterTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterTopicOK, error)

	CreateMsgVpnDmrBridge(params *CreateMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDmrBridgeOK, error)

	CreateMsgVpnJndiConnectionFactory(params *CreateMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnJndiConnectionFactoryOK, error)

	CreateMsgVpnJndiQueue(params *CreateMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnJndiQueueOK, error)

	CreateMsgVpnJndiTopic(params *CreateMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnJndiTopicOK, error)

	CreateMsgVpnMqttRetainCache(params *CreateMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnMqttRetainCacheOK, error)

	CreateMsgVpnMqttSession(params *CreateMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnMqttSessionOK, error)

	CreateMsgVpnMqttSessionSubscription(params *CreateMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnMqttSessionSubscriptionOK, error)

	CreateMsgVpnQueue(params *CreateMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnQueueOK, error)

	CreateMsgVpnQueueSubscription(params *CreateMsgVpnQueueSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnQueueSubscriptionOK, error)

	CreateMsgVpnQueueTemplate(params *CreateMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnQueueTemplateOK, error)

	CreateMsgVpnReplayLog(params *CreateMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnReplayLogOK, error)

	CreateMsgVpnReplicatedTopic(params *CreateMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnReplicatedTopicOK, error)

	CreateMsgVpnRestDeliveryPoint(params *CreateMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointOK, error)

	CreateMsgVpnRestDeliveryPointQueueBinding(params *CreateMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointQueueBindingOK, error)

	CreateMsgVpnRestDeliveryPointRestConsumer(params *CreateMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointRestConsumerOK, error)

	CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim(params *CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK, error)

	CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName(params *CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK, error)

	CreateMsgVpnSequencedTopic(params *CreateMsgVpnSequencedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnSequencedTopicOK, error)

	CreateMsgVpnTopicEndpoint(params *CreateMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnTopicEndpointOK, error)

	CreateMsgVpnTopicEndpointTemplate(params *CreateMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnTopicEndpointTemplateOK, error)

	CreateVirtualHostname(params *CreateVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateVirtualHostnameOK, error)

	DeleteCertAuthority(params *DeleteCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteCertAuthorityOK, error)

	DeleteCertAuthorityOcspTLSTrustedCommonName(params *DeleteCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteCertAuthorityOcspTLSTrustedCommonNameOK, error)

	DeleteClientCertAuthority(params *DeleteClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClientCertAuthorityOK, error)

	DeleteClientCertAuthorityOcspTLSTrustedCommonName(params *DeleteClientCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClientCertAuthorityOcspTLSTrustedCommonNameOK, error)

	DeleteDmrCluster(params *DeleteDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDmrClusterOK, error)

	DeleteDmrClusterLink(params *DeleteDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDmrClusterLinkOK, error)

	DeleteDmrClusterLinkRemoteAddress(params *DeleteDmrClusterLinkRemoteAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDmrClusterLinkRemoteAddressOK, error)

	DeleteDmrClusterLinkTLSTrustedCommonName(params *DeleteDmrClusterLinkTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDmrClusterLinkTLSTrustedCommonNameOK, error)

	DeleteDomainCertAuthority(params *DeleteDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDomainCertAuthorityOK, error)

	DeleteMsgVpn(params *DeleteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnOK, error)

	DeleteMsgVpnACLProfile(params *DeleteMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileOK, error)

	DeleteMsgVpnACLProfileClientConnectException(params *DeleteMsgVpnACLProfileClientConnectExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileClientConnectExceptionOK, error)

	DeleteMsgVpnACLProfilePublishException(params *DeleteMsgVpnACLProfilePublishExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfilePublishExceptionOK, error)

	DeleteMsgVpnACLProfilePublishTopicException(params *DeleteMsgVpnACLProfilePublishTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfilePublishTopicExceptionOK, error)

	DeleteMsgVpnACLProfileSubscribeException(params *DeleteMsgVpnACLProfileSubscribeExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileSubscribeExceptionOK, error)

	DeleteMsgVpnACLProfileSubscribeShareNameException(params *DeleteMsgVpnACLProfileSubscribeShareNameExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileSubscribeShareNameExceptionOK, error)

	DeleteMsgVpnACLProfileSubscribeTopicException(params *DeleteMsgVpnACLProfileSubscribeTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileSubscribeTopicExceptionOK, error)

	DeleteMsgVpnAuthenticationOauthProvider(params *DeleteMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnAuthenticationOauthProviderOK, error)

	DeleteMsgVpnAuthorizationGroup(params *DeleteMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnAuthorizationGroupOK, error)

	DeleteMsgVpnBridge(params *DeleteMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnBridgeOK, error)

	DeleteMsgVpnBridgeRemoteMsgVpn(params *DeleteMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnBridgeRemoteMsgVpnOK, error)

	DeleteMsgVpnBridgeRemoteSubscription(params *DeleteMsgVpnBridgeRemoteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnBridgeRemoteSubscriptionOK, error)

	DeleteMsgVpnBridgeTLSTrustedCommonName(params *DeleteMsgVpnBridgeTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnBridgeTLSTrustedCommonNameOK, error)

	DeleteMsgVpnClientProfile(params *DeleteMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnClientProfileOK, error)

	DeleteMsgVpnClientUsername(params *DeleteMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnClientUsernameOK, error)

	DeleteMsgVpnDistributedCache(params *DeleteMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheOK, error)

	DeleteMsgVpnDistributedCacheCluster(params *DeleteMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterOK, error)

	DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeCluster(params *DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK, error)

	DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix(params *DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK, error)

	DeleteMsgVpnDistributedCacheClusterInstance(params *DeleteMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterInstanceOK, error)

	DeleteMsgVpnDistributedCacheClusterTopic(params *DeleteMsgVpnDistributedCacheClusterTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterTopicOK, error)

	DeleteMsgVpnDmrBridge(params *DeleteMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDmrBridgeOK, error)

	DeleteMsgVpnJndiConnectionFactory(params *DeleteMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnJndiConnectionFactoryOK, error)

	DeleteMsgVpnJndiQueue(params *DeleteMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnJndiQueueOK, error)

	DeleteMsgVpnJndiTopic(params *DeleteMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnJndiTopicOK, error)

	DeleteMsgVpnMqttRetainCache(params *DeleteMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnMqttRetainCacheOK, error)

	DeleteMsgVpnMqttSession(params *DeleteMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnMqttSessionOK, error)

	DeleteMsgVpnMqttSessionSubscription(params *DeleteMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnMqttSessionSubscriptionOK, error)

	DeleteMsgVpnQueue(params *DeleteMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnQueueOK, error)

	DeleteMsgVpnQueueSubscription(params *DeleteMsgVpnQueueSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnQueueSubscriptionOK, error)

	DeleteMsgVpnQueueTemplate(params *DeleteMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnQueueTemplateOK, error)

	DeleteMsgVpnReplayLog(params *DeleteMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnReplayLogOK, error)

	DeleteMsgVpnReplicatedTopic(params *DeleteMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnReplicatedTopicOK, error)

	DeleteMsgVpnRestDeliveryPoint(params *DeleteMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointOK, error)

	DeleteMsgVpnRestDeliveryPointQueueBinding(params *DeleteMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointQueueBindingOK, error)

	DeleteMsgVpnRestDeliveryPointRestConsumer(params *DeleteMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointRestConsumerOK, error)

	DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim(params *DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK, error)

	DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName(params *DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK, error)

	DeleteMsgVpnSequencedTopic(params *DeleteMsgVpnSequencedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnSequencedTopicOK, error)

	DeleteMsgVpnTopicEndpoint(params *DeleteMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnTopicEndpointOK, error)

	DeleteMsgVpnTopicEndpointTemplate(params *DeleteMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnTopicEndpointTemplateOK, error)

	DeleteVirtualHostname(params *DeleteVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteVirtualHostnameOK, error)

	GetAbout(params *GetAboutParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutOK, error)

	GetAboutAPI(params *GetAboutAPIParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutAPIOK, error)

	GetAboutUser(params *GetAboutUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutUserOK, error)

	GetAboutUserMsgVpn(params *GetAboutUserMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutUserMsgVpnOK, error)

	GetAboutUserMsgVpns(params *GetAboutUserMsgVpnsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutUserMsgVpnsOK, error)

	GetBroker(params *GetBrokerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBrokerOK, error)

	GetCertAuthorities(params *GetCertAuthoritiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCertAuthoritiesOK, error)

	GetCertAuthority(params *GetCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCertAuthorityOK, error)

	GetCertAuthorityOcspTLSTrustedCommonName(params *GetCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCertAuthorityOcspTLSTrustedCommonNameOK, error)

	GetCertAuthorityOcspTLSTrustedCommonNames(params *GetCertAuthorityOcspTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCertAuthorityOcspTLSTrustedCommonNamesOK, error)

	GetClientCertAuthorities(params *GetClientCertAuthoritiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientCertAuthoritiesOK, error)

	GetClientCertAuthority(params *GetClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientCertAuthorityOK, error)

	GetClientCertAuthorityOcspTLSTrustedCommonName(params *GetClientCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientCertAuthorityOcspTLSTrustedCommonNameOK, error)

	GetClientCertAuthorityOcspTLSTrustedCommonNames(params *GetClientCertAuthorityOcspTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientCertAuthorityOcspTLSTrustedCommonNamesOK, error)

	GetDmrCluster(params *GetDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterOK, error)

	GetDmrClusterLink(params *GetDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkOK, error)

	GetDmrClusterLinkRemoteAddress(params *GetDmrClusterLinkRemoteAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkRemoteAddressOK, error)

	GetDmrClusterLinkRemoteAddresses(params *GetDmrClusterLinkRemoteAddressesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkRemoteAddressesOK, error)

	GetDmrClusterLinkTLSTrustedCommonName(params *GetDmrClusterLinkTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkTLSTrustedCommonNameOK, error)

	GetDmrClusterLinkTLSTrustedCommonNames(params *GetDmrClusterLinkTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkTLSTrustedCommonNamesOK, error)

	GetDmrClusterLinks(params *GetDmrClusterLinksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinksOK, error)

	GetDmrClusters(params *GetDmrClustersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClustersOK, error)

	GetDomainCertAuthorities(params *GetDomainCertAuthoritiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDomainCertAuthoritiesOK, error)

	GetDomainCertAuthority(params *GetDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDomainCertAuthorityOK, error)

	GetMsgVpn(params *GetMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnOK, error)

	GetMsgVpnACLProfile(params *GetMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileOK, error)

	GetMsgVpnACLProfileClientConnectException(params *GetMsgVpnACLProfileClientConnectExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileClientConnectExceptionOK, error)

	GetMsgVpnACLProfileClientConnectExceptions(params *GetMsgVpnACLProfileClientConnectExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileClientConnectExceptionsOK, error)

	GetMsgVpnACLProfilePublishException(params *GetMsgVpnACLProfilePublishExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilePublishExceptionOK, error)

	GetMsgVpnACLProfilePublishExceptions(params *GetMsgVpnACLProfilePublishExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilePublishExceptionsOK, error)

	GetMsgVpnACLProfilePublishTopicException(params *GetMsgVpnACLProfilePublishTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilePublishTopicExceptionOK, error)

	GetMsgVpnACLProfilePublishTopicExceptions(params *GetMsgVpnACLProfilePublishTopicExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilePublishTopicExceptionsOK, error)

	GetMsgVpnACLProfileSubscribeException(params *GetMsgVpnACLProfileSubscribeExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeExceptionOK, error)

	GetMsgVpnACLProfileSubscribeExceptions(params *GetMsgVpnACLProfileSubscribeExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeExceptionsOK, error)

	GetMsgVpnACLProfileSubscribeShareNameException(params *GetMsgVpnACLProfileSubscribeShareNameExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeShareNameExceptionOK, error)

	GetMsgVpnACLProfileSubscribeShareNameExceptions(params *GetMsgVpnACLProfileSubscribeShareNameExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeShareNameExceptionsOK, error)

	GetMsgVpnACLProfileSubscribeTopicException(params *GetMsgVpnACLProfileSubscribeTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeTopicExceptionOK, error)

	GetMsgVpnACLProfileSubscribeTopicExceptions(params *GetMsgVpnACLProfileSubscribeTopicExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeTopicExceptionsOK, error)

	GetMsgVpnACLProfiles(params *GetMsgVpnACLProfilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilesOK, error)

	GetMsgVpnAuthenticationOauthProvider(params *GetMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnAuthenticationOauthProviderOK, error)

	GetMsgVpnAuthenticationOauthProviders(params *GetMsgVpnAuthenticationOauthProvidersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnAuthenticationOauthProvidersOK, error)

	GetMsgVpnAuthorizationGroup(params *GetMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnAuthorizationGroupOK, error)

	GetMsgVpnAuthorizationGroups(params *GetMsgVpnAuthorizationGroupsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnAuthorizationGroupsOK, error)

	GetMsgVpnBridge(params *GetMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeOK, error)

	GetMsgVpnBridgeRemoteMsgVpn(params *GetMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeRemoteMsgVpnOK, error)

	GetMsgVpnBridgeRemoteMsgVpns(params *GetMsgVpnBridgeRemoteMsgVpnsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeRemoteMsgVpnsOK, error)

	GetMsgVpnBridgeRemoteSubscription(params *GetMsgVpnBridgeRemoteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeRemoteSubscriptionOK, error)

	GetMsgVpnBridgeRemoteSubscriptions(params *GetMsgVpnBridgeRemoteSubscriptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeRemoteSubscriptionsOK, error)

	GetMsgVpnBridgeTLSTrustedCommonName(params *GetMsgVpnBridgeTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeTLSTrustedCommonNameOK, error)

	GetMsgVpnBridgeTLSTrustedCommonNames(params *GetMsgVpnBridgeTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeTLSTrustedCommonNamesOK, error)

	GetMsgVpnBridges(params *GetMsgVpnBridgesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgesOK, error)

	GetMsgVpnClientProfile(params *GetMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnClientProfileOK, error)

	GetMsgVpnClientProfiles(params *GetMsgVpnClientProfilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnClientProfilesOK, error)

	GetMsgVpnClientUsername(params *GetMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnClientUsernameOK, error)

	GetMsgVpnClientUsernames(params *GetMsgVpnClientUsernamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnClientUsernamesOK, error)

	GetMsgVpnDistributedCache(params *GetMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheOK, error)

	GetMsgVpnDistributedCacheCluster(params *GetMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterOK, error)

	GetMsgVpnDistributedCacheClusterGlobalCachingHomeCluster(params *GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK, error)

	GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix(params *GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK, error)

	GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixes(params *GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixesOK, error)

	GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusters(params *GetMsgVpnDistributedCacheClusterGlobalCachingHomeClustersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClustersOK, error)

	GetMsgVpnDistributedCacheClusterInstance(params *GetMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterInstanceOK, error)

	GetMsgVpnDistributedCacheClusterInstances(params *GetMsgVpnDistributedCacheClusterInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterInstancesOK, error)

	GetMsgVpnDistributedCacheClusterTopic(params *GetMsgVpnDistributedCacheClusterTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterTopicOK, error)

	GetMsgVpnDistributedCacheClusterTopics(params *GetMsgVpnDistributedCacheClusterTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterTopicsOK, error)

	GetMsgVpnDistributedCacheClusters(params *GetMsgVpnDistributedCacheClustersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClustersOK, error)

	GetMsgVpnDistributedCaches(params *GetMsgVpnDistributedCachesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCachesOK, error)

	GetMsgVpnDmrBridge(params *GetMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDmrBridgeOK, error)

	GetMsgVpnDmrBridges(params *GetMsgVpnDmrBridgesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDmrBridgesOK, error)

	GetMsgVpnJndiConnectionFactories(params *GetMsgVpnJndiConnectionFactoriesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiConnectionFactoriesOK, error)

	GetMsgVpnJndiConnectionFactory(params *GetMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiConnectionFactoryOK, error)

	GetMsgVpnJndiQueue(params *GetMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiQueueOK, error)

	GetMsgVpnJndiQueues(params *GetMsgVpnJndiQueuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiQueuesOK, error)

	GetMsgVpnJndiTopic(params *GetMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiTopicOK, error)

	GetMsgVpnJndiTopics(params *GetMsgVpnJndiTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiTopicsOK, error)

	GetMsgVpnMqttRetainCache(params *GetMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttRetainCacheOK, error)

	GetMsgVpnMqttRetainCaches(params *GetMsgVpnMqttRetainCachesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttRetainCachesOK, error)

	GetMsgVpnMqttSession(params *GetMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttSessionOK, error)

	GetMsgVpnMqttSessionSubscription(params *GetMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttSessionSubscriptionOK, error)

	GetMsgVpnMqttSessionSubscriptions(params *GetMsgVpnMqttSessionSubscriptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttSessionSubscriptionsOK, error)

	GetMsgVpnMqttSessions(params *GetMsgVpnMqttSessionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttSessionsOK, error)

	GetMsgVpnQueue(params *GetMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueOK, error)

	GetMsgVpnQueueSubscription(params *GetMsgVpnQueueSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueSubscriptionOK, error)

	GetMsgVpnQueueSubscriptions(params *GetMsgVpnQueueSubscriptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueSubscriptionsOK, error)

	GetMsgVpnQueueTemplate(params *GetMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueTemplateOK, error)

	GetMsgVpnQueueTemplates(params *GetMsgVpnQueueTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueTemplatesOK, error)

	GetMsgVpnQueues(params *GetMsgVpnQueuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueuesOK, error)

	GetMsgVpnReplayLog(params *GetMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnReplayLogOK, error)

	GetMsgVpnReplayLogs(params *GetMsgVpnReplayLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnReplayLogsOK, error)

	GetMsgVpnReplicatedTopic(params *GetMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnReplicatedTopicOK, error)

	GetMsgVpnReplicatedTopics(params *GetMsgVpnReplicatedTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnReplicatedTopicsOK, error)

	GetMsgVpnRestDeliveryPoint(params *GetMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointOK, error)

	GetMsgVpnRestDeliveryPointQueueBinding(params *GetMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointQueueBindingOK, error)

	GetMsgVpnRestDeliveryPointQueueBindings(params *GetMsgVpnRestDeliveryPointQueueBindingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointQueueBindingsOK, error)

	GetMsgVpnRestDeliveryPointRestConsumer(params *GetMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerOK, error)

	GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim(params *GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK, error)

	GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaims(params *GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimsOK, error)

	GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName(params *GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK, error)

	GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNames(params *GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNamesOK, error)

	GetMsgVpnRestDeliveryPointRestConsumers(params *GetMsgVpnRestDeliveryPointRestConsumersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumersOK, error)

	GetMsgVpnRestDeliveryPoints(params *GetMsgVpnRestDeliveryPointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointsOK, error)

	GetMsgVpnSequencedTopic(params *GetMsgVpnSequencedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnSequencedTopicOK, error)

	GetMsgVpnSequencedTopics(params *GetMsgVpnSequencedTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnSequencedTopicsOK, error)

	GetMsgVpnTopicEndpoint(params *GetMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnTopicEndpointOK, error)

	GetMsgVpnTopicEndpointTemplate(params *GetMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnTopicEndpointTemplateOK, error)

	GetMsgVpnTopicEndpointTemplates(params *GetMsgVpnTopicEndpointTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnTopicEndpointTemplatesOK, error)

	GetMsgVpnTopicEndpoints(params *GetMsgVpnTopicEndpointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnTopicEndpointsOK, error)

	GetMsgVpns(params *GetMsgVpnsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnsOK, error)

	GetSystemInformation(params *GetSystemInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSystemInformationOK, error)

	GetVirtualHostname(params *GetVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetVirtualHostnameOK, error)

	GetVirtualHostnames(params *GetVirtualHostnamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetVirtualHostnamesOK, error)

	ReplaceCertAuthority(params *ReplaceCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceCertAuthorityOK, error)

	ReplaceClientCertAuthority(params *ReplaceClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceClientCertAuthorityOK, error)

	ReplaceDmrCluster(params *ReplaceDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceDmrClusterOK, error)

	ReplaceDmrClusterLink(params *ReplaceDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceDmrClusterLinkOK, error)

	ReplaceDomainCertAuthority(params *ReplaceDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceDomainCertAuthorityOK, error)

	ReplaceMsgVpn(params *ReplaceMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnOK, error)

	ReplaceMsgVpnACLProfile(params *ReplaceMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnACLProfileOK, error)

	ReplaceMsgVpnAuthenticationOauthProvider(params *ReplaceMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnAuthenticationOauthProviderOK, error)

	ReplaceMsgVpnAuthorizationGroup(params *ReplaceMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnAuthorizationGroupOK, error)

	ReplaceMsgVpnBridge(params *ReplaceMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnBridgeOK, error)

	ReplaceMsgVpnBridgeRemoteMsgVpn(params *ReplaceMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnBridgeRemoteMsgVpnOK, error)

	ReplaceMsgVpnClientProfile(params *ReplaceMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnClientProfileOK, error)

	ReplaceMsgVpnClientUsername(params *ReplaceMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnClientUsernameOK, error)

	ReplaceMsgVpnDistributedCache(params *ReplaceMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnDistributedCacheOK, error)

	ReplaceMsgVpnDistributedCacheCluster(params *ReplaceMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnDistributedCacheClusterOK, error)

	ReplaceMsgVpnDistributedCacheClusterInstance(params *ReplaceMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnDistributedCacheClusterInstanceOK, error)

	ReplaceMsgVpnDmrBridge(params *ReplaceMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnDmrBridgeOK, error)

	ReplaceMsgVpnJndiConnectionFactory(params *ReplaceMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnJndiConnectionFactoryOK, error)

	ReplaceMsgVpnJndiQueue(params *ReplaceMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnJndiQueueOK, error)

	ReplaceMsgVpnJndiTopic(params *ReplaceMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnJndiTopicOK, error)

	ReplaceMsgVpnMqttRetainCache(params *ReplaceMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnMqttRetainCacheOK, error)

	ReplaceMsgVpnMqttSession(params *ReplaceMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnMqttSessionOK, error)

	ReplaceMsgVpnMqttSessionSubscription(params *ReplaceMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnMqttSessionSubscriptionOK, error)

	ReplaceMsgVpnQueue(params *ReplaceMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnQueueOK, error)

	ReplaceMsgVpnQueueTemplate(params *ReplaceMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnQueueTemplateOK, error)

	ReplaceMsgVpnReplayLog(params *ReplaceMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnReplayLogOK, error)

	ReplaceMsgVpnReplicatedTopic(params *ReplaceMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnReplicatedTopicOK, error)

	ReplaceMsgVpnRestDeliveryPoint(params *ReplaceMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnRestDeliveryPointOK, error)

	ReplaceMsgVpnRestDeliveryPointQueueBinding(params *ReplaceMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnRestDeliveryPointQueueBindingOK, error)

	ReplaceMsgVpnRestDeliveryPointRestConsumer(params *ReplaceMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnRestDeliveryPointRestConsumerOK, error)

	ReplaceMsgVpnTopicEndpoint(params *ReplaceMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnTopicEndpointOK, error)

	ReplaceMsgVpnTopicEndpointTemplate(params *ReplaceMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnTopicEndpointTemplateOK, error)

	ReplaceVirtualHostname(params *ReplaceVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceVirtualHostnameOK, error)

	UpdateBroker(params *UpdateBrokerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateBrokerOK, error)

	UpdateCertAuthority(params *UpdateCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateCertAuthorityOK, error)

	UpdateClientCertAuthority(params *UpdateClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClientCertAuthorityOK, error)

	UpdateDmrCluster(params *UpdateDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateDmrClusterOK, error)

	UpdateDmrClusterLink(params *UpdateDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateDmrClusterLinkOK, error)

	UpdateDomainCertAuthority(params *UpdateDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateDomainCertAuthorityOK, error)

	UpdateMsgVpn(params *UpdateMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnOK, error)

	UpdateMsgVpnACLProfile(params *UpdateMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnACLProfileOK, error)

	UpdateMsgVpnAuthenticationOauthProvider(params *UpdateMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnAuthenticationOauthProviderOK, error)

	UpdateMsgVpnAuthorizationGroup(params *UpdateMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnAuthorizationGroupOK, error)

	UpdateMsgVpnBridge(params *UpdateMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnBridgeOK, error)

	UpdateMsgVpnBridgeRemoteMsgVpn(params *UpdateMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnBridgeRemoteMsgVpnOK, error)

	UpdateMsgVpnClientProfile(params *UpdateMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnClientProfileOK, error)

	UpdateMsgVpnClientUsername(params *UpdateMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnClientUsernameOK, error)

	UpdateMsgVpnDistributedCache(params *UpdateMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnDistributedCacheOK, error)

	UpdateMsgVpnDistributedCacheCluster(params *UpdateMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnDistributedCacheClusterOK, error)

	UpdateMsgVpnDistributedCacheClusterInstance(params *UpdateMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnDistributedCacheClusterInstanceOK, error)

	UpdateMsgVpnDmrBridge(params *UpdateMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnDmrBridgeOK, error)

	UpdateMsgVpnJndiConnectionFactory(params *UpdateMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnJndiConnectionFactoryOK, error)

	UpdateMsgVpnJndiQueue(params *UpdateMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnJndiQueueOK, error)

	UpdateMsgVpnJndiTopic(params *UpdateMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnJndiTopicOK, error)

	UpdateMsgVpnMqttRetainCache(params *UpdateMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnMqttRetainCacheOK, error)

	UpdateMsgVpnMqttSession(params *UpdateMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnMqttSessionOK, error)

	UpdateMsgVpnMqttSessionSubscription(params *UpdateMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnMqttSessionSubscriptionOK, error)

	UpdateMsgVpnQueue(params *UpdateMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnQueueOK, error)

	UpdateMsgVpnQueueTemplate(params *UpdateMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnQueueTemplateOK, error)

	UpdateMsgVpnReplayLog(params *UpdateMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnReplayLogOK, error)

	UpdateMsgVpnReplicatedTopic(params *UpdateMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnReplicatedTopicOK, error)

	UpdateMsgVpnRestDeliveryPoint(params *UpdateMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnRestDeliveryPointOK, error)

	UpdateMsgVpnRestDeliveryPointQueueBinding(params *UpdateMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnRestDeliveryPointQueueBindingOK, error)

	UpdateMsgVpnRestDeliveryPointRestConsumer(params *UpdateMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnRestDeliveryPointRestConsumerOK, error)

	UpdateMsgVpnTopicEndpoint(params *UpdateMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnTopicEndpointOK, error)

	UpdateMsgVpnTopicEndpointTemplate(params *UpdateMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnTopicEndpointTemplateOK, error)

	UpdateVirtualHostname(params *UpdateVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateVirtualHostnameOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CreateCertAuthority creates a certificate authority object

  Create a Certificate Authority object. Any attribute missing from the request will be set to its default value.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x|||x|
certContent|||||x|
crlDayList|||||x|
crlTimeList|||||x|
crlUrl|||||x|
ocspNonResponderCertEnabled|||||x|
ocspOverrideUrl|||||x|
ocspTimeout|||||x|
revocationCheckEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
CertAuthority|crlDayList|crlTimeList|
CertAuthority|crlTimeList|crlDayList|



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities and domainCertAuthorities.
*/
func (a *Client) CreateCertAuthority(params *CreateCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createCertAuthority",
		Method:             "POST",
		PathPattern:        "/certAuthorities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateCertAuthorityOcspTLSTrustedCommonName creates an o c s p responder trusted common name object

  Create an OCSP Responder Trusted Common Name object. Any attribute missing from the request will be set to its default value.

When an OCSP override URL is configured, the OCSP responder will be required to sign the OCSP responses with certificates issued to these Trusted Common Names. A maximum of 8 common names can be configured as valid response signers.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x||x||x|
ocspTlsTrustedCommonName|x|x|||x|



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities.
*/
func (a *Client) CreateCertAuthorityOcspTLSTrustedCommonName(params *CreateCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateCertAuthorityOcspTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCertAuthorityOcspTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createCertAuthorityOcspTlsTrustedCommonName",
		Method:             "POST",
		PathPattern:        "/certAuthorities/{certAuthorityName}/ocspTlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateCertAuthorityOcspTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateCertAuthorityOcspTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateCertAuthorityOcspTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateClientCertAuthority creates a client certificate authority object

  Create a Client Certificate Authority object. Any attribute missing from the request will be set to its default value.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
ClientCertAuthority|crlDayList|crlTimeList|
ClientCertAuthority|crlTimeList|crlDayList|



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) CreateClientCertAuthority(params *CreateClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClientCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClientCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createClientCertAuthority",
		Method:             "POST",
		PathPattern:        "/clientCertAuthorities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateClientCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateClientCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateClientCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateClientCertAuthorityOcspTLSTrustedCommonName creates an o c s p responder trusted common name object

  Create an OCSP Responder Trusted Common Name object. Any attribute missing from the request will be set to its default value.

When an OCSP override URL is configured, the OCSP responder will be required to sign the OCSP responses with certificates issued to these Trusted Common Names. A maximum of 8 common names can be configured as valid response signers.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x||x|||
ocspTlsTrustedCommonName|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) CreateClientCertAuthorityOcspTLSTrustedCommonName(params *CreateClientCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClientCertAuthorityOcspTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClientCertAuthorityOcspTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createClientCertAuthorityOcspTlsTrustedCommonName",
		Method:             "POST",
		PathPattern:        "/clientCertAuthorities/{certAuthorityName}/ocspTlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateClientCertAuthorityOcspTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateClientCertAuthorityOcspTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateClientCertAuthorityOcspTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateDmrCluster creates a cluster object

  Create a Cluster object. Any attribute missing from the request will be set to its default value.

A Cluster is a provisioned object on a message broker that contains global DMR configuration parameters.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationBasicPassword||||x||x
authenticationClientCertContent||||x||x
authenticationClientCertPassword||||x||
dmrClusterName|x|x||||
nodeName|||x|||
tlsServerCertEnforceTrustedCommonNameEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
DmrCluster|authenticationClientCertPassword|authenticationClientCertContent|



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateDmrCluster(params *CreateDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDmrClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDmrClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createDmrCluster",
		Method:             "POST",
		PathPattern:        "/dmrClusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDmrClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateDmrClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateDmrClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateDmrClusterLink creates a link object

  Create a Link object. Any attribute missing from the request will be set to its default value.

A Link connects nodes (either within a Cluster or between two different Clusters) and allows them to exchange topology information, subscriptions and data.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationBasicPassword||||x||x
dmrClusterName|x||x|||
remoteNodeName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateDmrClusterLink(params *CreateDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDmrClusterLinkOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDmrClusterLinkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createDmrClusterLink",
		Method:             "POST",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDmrClusterLinkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateDmrClusterLinkOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateDmrClusterLinkDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateDmrClusterLinkRemoteAddress creates a remote address object

  Create a Remote Address object. Any attribute missing from the request will be set to its default value.

Each Remote Address, consisting of a FQDN or IP address and optional port, is used to connect to the remote node for this Link. Up to 4 addresses may be provided for each Link, and will be tried on a round-robin basis.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
dmrClusterName|x||x|||
remoteAddress|x|x||||
remoteNodeName|x||x|||



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateDmrClusterLinkRemoteAddress(params *CreateDmrClusterLinkRemoteAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDmrClusterLinkRemoteAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDmrClusterLinkRemoteAddressParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createDmrClusterLinkRemoteAddress",
		Method:             "POST",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}/remoteAddresses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDmrClusterLinkRemoteAddressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateDmrClusterLinkRemoteAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateDmrClusterLinkRemoteAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateDmrClusterLinkTLSTrustedCommonName creates a trusted common name object

  Create a Trusted Common Name object. Any attribute missing from the request will be set to its default value.

The Trusted Common Names for the Link are used by encrypted transports to verify the name in the certificate presented by the remote node. They must include the common name of the remote node's server certificate or client certificate, depending upon the initiator of the connection.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
dmrClusterName|x||x||x|
remoteNodeName|x||x||x|
tlsTrustedCommonName|x|x|||x|



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been deprecated since 2.18. Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) CreateDmrClusterLinkTLSTrustedCommonName(params *CreateDmrClusterLinkTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDmrClusterLinkTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDmrClusterLinkTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createDmrClusterLinkTlsTrustedCommonName",
		Method:             "POST",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}/tlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDmrClusterLinkTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateDmrClusterLinkTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateDmrClusterLinkTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateDomainCertAuthority creates a domain certificate authority object

  Create a Domain Certificate Authority object. Any attribute missing from the request will be set to its default value.

Certificate Authorities trusted for domain verification.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) CreateDomainCertAuthority(params *CreateDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDomainCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDomainCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createDomainCertAuthority",
		Method:             "POST",
		PathPattern:        "/domainCertAuthorities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDomainCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateDomainCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateDomainCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpn creates a message v p n object

  Create a Message VPN object. Any attribute missing from the request will be set to its default value.

Message VPNs (Virtual Private Networks) allow for the segregation of topic space and clients. They also group clients connecting to a network of message brokers, such that messages published within a particular group are only visible to that group's clients.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgingTlsServerCertEnforceTrustedCommonNameEnabled|||||x|
msgVpnName|x|x||||
replicationBridgeAuthenticationBasicPassword||||x||x
replicationBridgeAuthenticationClientCertContent||||x||x
replicationBridgeAuthenticationClientCertPassword||||x||
replicationEnabledQueueBehavior||||x||
restTlsServerCertEnforceTrustedCommonNameEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent
EventThresholdByValue|clearValue|setValue|
EventThresholdByValue|setValue|clearValue|
MsgVpn|authenticationBasicProfileName|authenticationBasicType|
MsgVpn|authorizationProfileName|authorizationType|
MsgVpn|eventPublishTopicFormatMqttEnabled|eventPublishTopicFormatSmfEnabled|
MsgVpn|eventPublishTopicFormatSmfEnabled|eventPublishTopicFormatMqttEnabled|
MsgVpn|replicationBridgeAuthenticationBasicClientUsername|replicationBridgeAuthenticationBasicPassword|
MsgVpn|replicationBridgeAuthenticationBasicPassword|replicationBridgeAuthenticationBasicClientUsername|
MsgVpn|replicationBridgeAuthenticationClientCertPassword|replicationBridgeAuthenticationClientCertContent|
MsgVpn|replicationEnabledQueueBehavior|replicationEnabled|



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpn(params *CreateMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpn",
		Method:             "POST",
		PathPattern:        "/msgVpns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnACLProfile creates an ACL profile object

  Create an ACL Profile object. Any attribute missing from the request will be set to its default value.

An ACL Profile controls whether an authenticated client is permitted to establish a connection with the message broker or permitted to publish and subscribe to specific topics.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x|x||||
msgVpnName|x||x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnACLProfile(params *CreateMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnACLProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAclProfile",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnACLProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnACLProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnACLProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnACLProfileClientConnectException creates a client connect exception object

  Create a Client Connect Exception object. Any attribute missing from the request will be set to its default value.

A Client Connect Exception is an exception to the default action to take when a client using the ACL Profile connects to the Message VPN. Exceptions must be expressed as an IP address/netmask in CIDR form.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x||x|||
clientConnectExceptionAddress|x|x||||
msgVpnName|x||x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnACLProfileClientConnectException(params *CreateMsgVpnACLProfileClientConnectExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileClientConnectExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnACLProfileClientConnectExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAclProfileClientConnectException",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/clientConnectExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnACLProfileClientConnectExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnACLProfileClientConnectExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnACLProfileClientConnectExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnACLProfilePublishException creates a publish topic exception object

  Create a Publish Topic Exception object. Any attribute missing from the request will be set to its default value.

A Publish Topic Exception is an exception to the default action to take when a client using the ACL Profile publishes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x||x||x|
msgVpnName|x||x||x|
publishExceptionTopic|x|x|||x|
topicSyntax|x|x|||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been deprecated since 2.14. Replaced by publishTopicExceptions.
*/
func (a *Client) CreateMsgVpnACLProfilePublishException(params *CreateMsgVpnACLProfilePublishExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfilePublishExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnACLProfilePublishExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAclProfilePublishException",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/publishExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnACLProfilePublishExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnACLProfilePublishExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnACLProfilePublishExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnACLProfilePublishTopicException creates a publish topic exception object

  Create a Publish Topic Exception object. Any attribute missing from the request will be set to its default value.

A Publish Topic Exception is an exception to the default action to take when a client using the ACL Profile publishes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x||x|||
msgVpnName|x||x|||
publishTopicException|x|x||||
publishTopicExceptionSyntax|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) CreateMsgVpnACLProfilePublishTopicException(params *CreateMsgVpnACLProfilePublishTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfilePublishTopicExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnACLProfilePublishTopicExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAclProfilePublishTopicException",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/publishTopicExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnACLProfilePublishTopicExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnACLProfilePublishTopicExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnACLProfilePublishTopicExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnACLProfileSubscribeException creates a subscribe topic exception object

  Create a Subscribe Topic Exception object. Any attribute missing from the request will be set to its default value.

A Subscribe Topic Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x||x||x|
msgVpnName|x||x||x|
subscribeExceptionTopic|x|x|||x|
topicSyntax|x|x|||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been deprecated since 2.14. Replaced by subscribeTopicExceptions.
*/
func (a *Client) CreateMsgVpnACLProfileSubscribeException(params *CreateMsgVpnACLProfileSubscribeExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileSubscribeExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnACLProfileSubscribeExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAclProfileSubscribeException",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnACLProfileSubscribeExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnACLProfileSubscribeExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnACLProfileSubscribeExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnACLProfileSubscribeShareNameException creates a subscribe share name exception object

  Create a Subscribe Share Name Exception object. Any attribute missing from the request will be set to its default value.

A Subscribe Share Name Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a share-name subscription in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x||x|||
msgVpnName|x||x|||
subscribeShareNameException|x|x||||
subscribeShareNameExceptionSyntax|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) CreateMsgVpnACLProfileSubscribeShareNameException(params *CreateMsgVpnACLProfileSubscribeShareNameExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileSubscribeShareNameExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnACLProfileSubscribeShareNameExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAclProfileSubscribeShareNameException",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeShareNameExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnACLProfileSubscribeShareNameExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnACLProfileSubscribeShareNameExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnACLProfileSubscribeShareNameExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnACLProfileSubscribeTopicException creates a subscribe topic exception object

  Create a Subscribe Topic Exception object. Any attribute missing from the request will be set to its default value.

A Subscribe Topic Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x||x|||
msgVpnName|x||x|||
subscribeTopicException|x|x||||
subscribeTopicExceptionSyntax|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) CreateMsgVpnACLProfileSubscribeTopicException(params *CreateMsgVpnACLProfileSubscribeTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnACLProfileSubscribeTopicExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnACLProfileSubscribeTopicExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAclProfileSubscribeTopicException",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeTopicExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnACLProfileSubscribeTopicExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnACLProfileSubscribeTopicExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnACLProfileSubscribeTopicExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnAuthenticationOauthProvider creates an o auth provider object

  Create an OAuth Provider object. Any attribute missing from the request will be set to its default value.

OAuth Providers contain information about the issuer of an OAuth token that is needed to validate the token and derive a client username from it.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
oauthProviderName|x|x||||
tokenIntrospectionPassword||||x||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.13.
*/
func (a *Client) CreateMsgVpnAuthenticationOauthProvider(params *CreateMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnAuthenticationOauthProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnAuthenticationOauthProviderParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAuthenticationOauthProvider",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/authenticationOauthProviders",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnAuthenticationOauthProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnAuthenticationOauthProviderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnAuthenticationOauthProviderDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnAuthorizationGroup creates an l d a p authorization group object

  Create an LDAP Authorization Group object. Any attribute missing from the request will be set to its default value.

To use client authorization groups configured on an external LDAP server to provide client authorizations, LDAP Authorization Group objects must be created on the Message VPN that match the authorization groups provisioned on the LDAP server. These objects must be configured with the client profiles and ACL profiles that will be assigned to the clients that belong to those authorization groups. A newly created group is placed at the end of the group list which is the lowest priority.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authorizationGroupName|x|x||||
msgVpnName|x||x|||
orderAfterAuthorizationGroupName||||x||
orderBeforeAuthorizationGroupName||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnAuthorizationGroup|orderAfterAuthorizationGroupName||orderBeforeAuthorizationGroupName
MsgVpnAuthorizationGroup|orderBeforeAuthorizationGroupName||orderAfterAuthorizationGroupName



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnAuthorizationGroup(params *CreateMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnAuthorizationGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnAuthorizationGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnAuthorizationGroup",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/authorizationGroups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnAuthorizationGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnAuthorizationGroupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnAuthorizationGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnBridge creates a bridge object

  Create a Bridge object. Any attribute missing from the request will be set to its default value.

Bridges can be used to link two Message VPNs so that messages published to one Message VPN that match the topic subscriptions set for the bridge are also delivered to the linked Message VPN.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgeName|x|x||||
bridgeVirtualRouter|x|x||||
msgVpnName|x||x|||
remoteAuthenticationBasicPassword||||x||x
remoteAuthenticationClientCertContent||||x||x
remoteAuthenticationClientCertPassword||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnBridge|remoteAuthenticationBasicClientUsername|remoteAuthenticationBasicPassword|
MsgVpnBridge|remoteAuthenticationBasicPassword|remoteAuthenticationBasicClientUsername|
MsgVpnBridge|remoteAuthenticationClientCertPassword|remoteAuthenticationClientCertContent|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnBridge(params *CreateMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnBridge",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnBridgeRemoteMsgVpn creates a remote message v p n object

  Create a Remote Message VPN object. Any attribute missing from the request will be set to its default value.

The Remote Message VPN is the Message VPN that the Bridge connects to.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgeName|x||x|||
bridgeVirtualRouter|x||x|||
msgVpnName|x||x|||
password||||x||x
remoteMsgVpnInterface|x|||||
remoteMsgVpnLocation|x|x||||
remoteMsgVpnName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnBridgeRemoteMsgVpn|clientUsername|password|
MsgVpnBridgeRemoteMsgVpn|password|clientUsername|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnBridgeRemoteMsgVpn(params *CreateMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnBridgeRemoteMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnBridgeRemoteMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnBridgeRemoteMsgVpn",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteMsgVpns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnBridgeRemoteMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnBridgeRemoteMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnBridgeRemoteMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnBridgeRemoteSubscription creates a remote subscription object

  Create a Remote Subscription object. Any attribute missing from the request will be set to its default value.

A Remote Subscription is a topic subscription used by the Message VPN Bridge to attract messages from the remote message broker.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgeName|x||x|||
bridgeVirtualRouter|x||x|||
deliverAlwaysEnabled||x||||
msgVpnName|x||x|||
remoteSubscriptionTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnBridgeRemoteSubscription(params *CreateMsgVpnBridgeRemoteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnBridgeRemoteSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnBridgeRemoteSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnBridgeRemoteSubscription",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteSubscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnBridgeRemoteSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnBridgeRemoteSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnBridgeRemoteSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnBridgeTLSTrustedCommonName creates a trusted common name object

  Create a Trusted Common Name object. Any attribute missing from the request will be set to its default value.

The Trusted Common Names for the Bridge are used by encrypted transports to verify the name in the certificate presented by the remote node. They must include the common name of the remote node's server certificate or client certificate, depending upon the initiator of the connection.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgeName|x||x||x|
bridgeVirtualRouter|x||x||x|
msgVpnName|x||x||x|
tlsTrustedCommonName|x|x|||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been deprecated since 2.18. Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) CreateMsgVpnBridgeTLSTrustedCommonName(params *CreateMsgVpnBridgeTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnBridgeTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnBridgeTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnBridgeTlsTrustedCommonName",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/tlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnBridgeTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnBridgeTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnBridgeTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnClientProfile creates a client profile object

  Create a Client Profile object. Any attribute missing from the request will be set to its default value.

Client Profiles are used to assign common configuration properties to clients that have been successfully authorized.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
apiQueueManagementCopyFromOnCreateName|||||x|
apiTopicEndpointManagementCopyFromOnCreateName|||||x|
clientProfileName|x|x||||
msgVpnName|x||x|||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent
EventThresholdByPercent|clearPercent|setPercent|
EventThresholdByPercent|setPercent|clearPercent|



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnClientProfile(params *CreateMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnClientProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnClientProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnClientProfile",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/clientProfiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnClientProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnClientProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnClientProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnClientUsername creates a client username object

  Create a Client Username object. Any attribute missing from the request will be set to its default value.

A client is only authorized to connect to a Message VPN that is associated with a Client Username that the client has been assigned.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
clientUsername|x|x||||
msgVpnName|x||x|||
password||||x||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnClientUsername(params *CreateMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnClientUsernameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnClientUsernameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnClientUsername",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/clientUsernames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnClientUsernameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnClientUsernameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnClientUsernameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnDistributedCache creates a distributed cache object

  Create a Distributed Cache object. Any attribute missing from the request will be set to its default value.

A Distributed Cache is a collection of one or more Cache Clusters that belong to the same Message VPN. Each Cache Cluster in a Distributed Cache is configured to subscribe to a different set of topics. This effectively divides up the configured topic space, to provide scaling to very large topic spaces or very high cached message throughput.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
msgVpnName|x||x|||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnDistributedCache|scheduledDeleteMsgDayList|scheduledDeleteMsgTimeList|
MsgVpnDistributedCache|scheduledDeleteMsgTimeList|scheduledDeleteMsgDayList|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateMsgVpnDistributedCache(params *CreateMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnDistributedCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnDistributedCache",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnDistributedCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnDistributedCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnDistributedCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnDistributedCacheCluster creates a cache cluster object

  Create a Cache Cluster object. Any attribute missing from the request will be set to its default value.

A Cache Cluster is a collection of one or more Cache Instances that subscribe to exactly the same topics. Cache Instances are grouped together in a Cache Cluster for the purpose of fault tolerance and load balancing. As published messages are received, the message broker message bus sends these live data messages to the Cache Instances in the Cache Cluster. This enables client cache requests to be served by any of Cache Instances in the Cache Cluster.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x||x|||
clusterName|x|x||||
msgVpnName|x||x|||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThresholdByPercent|clearPercent|setPercent|
EventThresholdByPercent|setPercent|clearPercent|
EventThresholdByValue|clearValue|setValue|
EventThresholdByValue|setValue|clearValue|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateMsgVpnDistributedCacheCluster(params *CreateMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnDistributedCacheClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnDistributedCacheCluster",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnDistributedCacheClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnDistributedCacheClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnDistributedCacheClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnDistributedCacheClusterGlobalCachingHomeCluster creates a home cache cluster object

  Create a Home Cache Cluster object. Any attribute missing from the request will be set to its default value.

A Home Cache Cluster is a Cache Cluster that is the "definitive" Cache Cluster for a given topic in the context of the Global Caching feature.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x||x|||
clusterName|x||x|||
homeClusterName|x|x||||
msgVpnName|x||x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateMsgVpnDistributedCacheClusterGlobalCachingHomeCluster(params *CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnDistributedCacheClusterGlobalCachingHomeCluster",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/globalCachingHomeClusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix creates a topic prefix object

  Create a Topic Prefix object. Any attribute missing from the request will be set to its default value.

A Topic Prefix is a prefix for a global topic that is available from the containing Home Cache Cluster.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x||x|||
clusterName|x||x|||
homeClusterName|x||x|||
msgVpnName|x||x|||
topicPrefix|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix(params *CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/globalCachingHomeClusters/{homeClusterName}/topicPrefixes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnDistributedCacheClusterInstance creates a cache instance object

  Create a Cache Instance object. Any attribute missing from the request will be set to its default value.

A Cache Instance is a single Cache process that belongs to a single Cache Cluster. A Cache Instance object provisioned on the broker is used to disseminate configuration information to the Cache process. Cache Instances listen for and cache live data messages that match the topic subscriptions configured for their parent Cache Cluster.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x||x|||
clusterName|x||x|||
instanceName|x|x||||
msgVpnName|x||x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateMsgVpnDistributedCacheClusterInstance(params *CreateMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterInstanceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnDistributedCacheClusterInstanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnDistributedCacheClusterInstance",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnDistributedCacheClusterInstanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnDistributedCacheClusterInstanceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnDistributedCacheClusterInstanceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnDistributedCacheClusterTopic creates a topic object

  Create a Topic object. Any attribute missing from the request will be set to its default value.

The Cache Instances that belong to the containing Cache Cluster will cache any messages published to topics that match a Topic Subscription.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x||x|||
clusterName|x||x|||
msgVpnName|x||x|||
topic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateMsgVpnDistributedCacheClusterTopic(params *CreateMsgVpnDistributedCacheClusterTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDistributedCacheClusterTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnDistributedCacheClusterTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnDistributedCacheClusterTopic",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/topics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnDistributedCacheClusterTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnDistributedCacheClusterTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnDistributedCacheClusterTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnDmrBridge creates a d m r bridge object

  Create a DMR Bridge object. Any attribute missing from the request will be set to its default value.

A DMR Bridge is required to establish a data channel over a corresponding external link to the remote node for a given Message VPN. Each DMR Bridge identifies which external link the Message VPN should use, and what the name of the equivalent Message VPN at the remote node is.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
remoteNodeName|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateMsgVpnDmrBridge(params *CreateMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnDmrBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnDmrBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnDmrBridge",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/dmrBridges",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnDmrBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnDmrBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnDmrBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnJndiConnectionFactory creates a j n d i connection factory object

  Create a JNDI Connection Factory object. Any attribute missing from the request will be set to its default value.

The message broker provides an internal JNDI store for provisioned Connection Factory objects that clients can access through JNDI lookups.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
connectionFactoryName|x|x||||
msgVpnName|x||x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) CreateMsgVpnJndiConnectionFactory(params *CreateMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnJndiConnectionFactoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnJndiConnectionFactoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnJndiConnectionFactory",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiConnectionFactories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnJndiConnectionFactoryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnJndiConnectionFactoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnJndiConnectionFactoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnJndiQueue creates a j n d i queue object

  Create a JNDI Queue object. Any attribute missing from the request will be set to its default value.

The message broker provides an internal JNDI store for provisioned Queue objects that clients can access through JNDI lookups.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
queueName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) CreateMsgVpnJndiQueue(params *CreateMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnJndiQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnJndiQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnJndiQueue",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiQueues",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnJndiQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnJndiQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnJndiQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnJndiTopic creates a j n d i topic object

  Create a JNDI Topic object. Any attribute missing from the request will be set to its default value.

The message broker provides an internal JNDI store for provisioned Topic objects that clients can access through JNDI lookups.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
topicName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) CreateMsgVpnJndiTopic(params *CreateMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnJndiTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnJndiTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnJndiTopic",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiTopics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnJndiTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnJndiTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnJndiTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnMqttRetainCache creates an m q t t retain cache object

  Create an MQTT Retain Cache object. Any attribute missing from the request will be set to its default value.

Using MQTT retained messages allows publishing MQTT clients to indicate that a message must be stored for later delivery to subscribing clients when those subscribing clients add subscriptions matching the retained message's topic. An MQTT Retain Cache processes all retained messages for a Message VPN.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
msgVpnName|x||x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) CreateMsgVpnMqttRetainCache(params *CreateMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnMqttRetainCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnMqttRetainCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnMqttRetainCache",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttRetainCaches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnMqttRetainCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnMqttRetainCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnMqttRetainCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnMqttSession creates an m q t t session object

  Create an MQTT Session object. Any attribute missing from the request will be set to its default value.

An MQTT Session object is a virtual representation of an MQTT client connection. An MQTT session holds the state of an MQTT client (that is, it is used to contain a client's QoS 0 and QoS 1 subscription sets and any undelivered QoS 1 messages).


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
mqttSessionClientId|x|x||||
mqttSessionVirtualRouter|x|x||||
msgVpnName|x||x|||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) CreateMsgVpnMqttSession(params *CreateMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnMqttSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnMqttSessionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnMqttSession",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnMqttSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnMqttSessionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnMqttSessionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnMqttSessionSubscription creates a subscription object

  Create a Subscription object. Any attribute missing from the request will be set to its default value.

An MQTT session contains a client's QoS 0 and QoS 1 subscription sets. On creation, a subscription defaults to QoS 0.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
mqttSessionClientId|x||x|||
mqttSessionVirtualRouter|x||x|||
msgVpnName|x||x|||
subscriptionTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) CreateMsgVpnMqttSessionSubscription(params *CreateMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnMqttSessionSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnMqttSessionSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnMqttSessionSubscription",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}/subscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnMqttSessionSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnMqttSessionSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnMqttSessionSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnQueue creates a queue object

  Create a Queue object. Any attribute missing from the request will be set to its default value.

A Queue acts as both a destination that clients can publish messages to, and as an endpoint that clients can bind consumers to and consume messages from.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
queueName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnQueue(params *CreateMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnQueue",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/queues",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnQueueSubscription creates a queue subscription object

  Create a Queue Subscription object. Any attribute missing from the request will be set to its default value.

One or more Queue Subscriptions can be added to a durable queue so that Guaranteed messages published to matching topics are also delivered to and spooled by the queue.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
queueName|x||x|||
subscriptionTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnQueueSubscription(params *CreateMsgVpnQueueSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnQueueSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnQueueSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnQueueSubscription",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/queues/{queueName}/subscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnQueueSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnQueueSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnQueueSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnQueueTemplate creates a queue template object

  Create a Queue Template object. Any attribute missing from the request will be set to its default value.

A Queue Template provides a mechanism for specifying the initial state for client created queues.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
queueTemplateName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) CreateMsgVpnQueueTemplate(params *CreateMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnQueueTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnQueueTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnQueueTemplate",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/queueTemplates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnQueueTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnQueueTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnQueueTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnReplayLog creates a replay log object

  Create a Replay Log object. Any attribute missing from the request will be set to its default value.

When the Message Replay feature is enabled, message brokers store persistent messages in a Replay Log. These messages are kept until the log is full, after which the oldest messages are removed to free up space for new messages.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
replayLogName|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.10.
*/
func (a *Client) CreateMsgVpnReplayLog(params *CreateMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnReplayLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnReplayLogParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnReplayLog",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/replayLogs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnReplayLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnReplayLogOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnReplayLogDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnReplicatedTopic creates a replicated topic object

  Create a Replicated Topic object. Any attribute missing from the request will be set to its default value.

To indicate which messages should be replicated between the active and standby site, a Replicated Topic subscription must be configured on a Message VPN. If a published message matches both a replicated topic and an endpoint on the active site, then the message is replicated to the standby site.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
replicatedTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) CreateMsgVpnReplicatedTopic(params *CreateMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnReplicatedTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnReplicatedTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnReplicatedTopic",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/replicatedTopics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnReplicatedTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnReplicatedTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnReplicatedTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnRestDeliveryPoint creates a r e s t delivery point object

  Create a REST Delivery Point object. Any attribute missing from the request will be set to its default value.

A REST Delivery Point manages delivery of messages from queues to a named list of REST Consumers.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
restDeliveryPointName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnRestDeliveryPoint(params *CreateMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnRestDeliveryPointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnRestDeliveryPoint",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnRestDeliveryPointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnRestDeliveryPointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnRestDeliveryPointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnRestDeliveryPointQueueBinding creates a queue binding object

  Create a Queue Binding object. Any attribute missing from the request will be set to its default value.

A Queue Binding for a REST Delivery Point attracts messages to be delivered to REST consumers. If the queue does not exist it can be created subsequently, and once the queue is operational the broker performs the queue binding. Removing the queue binding does not delete the queue itself. Similarly, removing the queue does not remove the queue binding, which fails until the queue is recreated or the queue binding is deleted.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
queueBindingName|x|x||||
restDeliveryPointName|x||x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnRestDeliveryPointQueueBinding(params *CreateMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointQueueBindingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnRestDeliveryPointQueueBindingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnRestDeliveryPointQueueBinding",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/queueBindings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnRestDeliveryPointQueueBindingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnRestDeliveryPointQueueBindingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnRestDeliveryPointQueueBindingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnRestDeliveryPointRestConsumer creates a r e s t consumer object

  Create a REST Consumer object. Any attribute missing from the request will be set to its default value.

REST Consumer objects establish HTTP connectivity to REST consumer applications who wish to receive messages from a broker.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationClientCertContent||||x||x
authenticationClientCertPassword||||x||
authenticationHttpBasicPassword||||x||x
authenticationHttpHeaderValue||||x||x
authenticationOauthClientSecret||||x||x
authenticationOauthJwtSecretKey||||x||x
msgVpnName|x||x|||
restConsumerName|x|x||||
restDeliveryPointName|x||x|||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnRestDeliveryPointRestConsumer|authenticationClientCertPassword|authenticationClientCertContent|
MsgVpnRestDeliveryPointRestConsumer|authenticationHttpBasicPassword|authenticationHttpBasicUsername|
MsgVpnRestDeliveryPointRestConsumer|authenticationHttpBasicUsername|authenticationHttpBasicPassword|
MsgVpnRestDeliveryPointRestConsumer|remotePort|tlsEnabled|
MsgVpnRestDeliveryPointRestConsumer|tlsEnabled|remotePort|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnRestDeliveryPointRestConsumer(params *CreateMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointRestConsumerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnRestDeliveryPointRestConsumerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnRestDeliveryPointRestConsumer",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnRestDeliveryPointRestConsumerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnRestDeliveryPointRestConsumerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnRestDeliveryPointRestConsumerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim creates a claim object

  Create a Claim object. Any attribute missing from the request will be set to its default value.

A Claim is added to the JWT sent to the OAuth token request endpoint.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
oauthJwtClaimName|x|x||||
oauthJwtClaimValue||x||||
restConsumerName|x||x|||
restDeliveryPointName|x||x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.21.
*/
func (a *Client) CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim(params *CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}/oauthJwtClaims",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName creates a trusted common name object

  Create a Trusted Common Name object. Any attribute missing from the request will be set to its default value.

The Trusted Common Names for the REST Consumer are used by encrypted transports to verify the name in the certificate presented by the remote REST consumer. They must include the common name of the remote REST consumer's server certificate.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x||x|
restConsumerName|x||x||x|
restDeliveryPointName|x||x||x|
tlsTrustedCommonName|x|x|||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been deprecated since (will be deprecated in next SEMP version). Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName(params *CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnRestDeliveryPointRestConsumerTlsTrustedCommonName",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}/tlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnSequencedTopic creates a sequenced topic object

  Create a Sequenced Topic object. Any attribute missing from the request will be set to its default value.

A Sequenced Topic is a topic subscription for which any matching messages received on the Message VPN are assigned a sequence number that is monotonically increased by a value of one per message.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
sequencedTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) CreateMsgVpnSequencedTopic(params *CreateMsgVpnSequencedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnSequencedTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnSequencedTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnSequencedTopic",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/sequencedTopics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnSequencedTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnSequencedTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnSequencedTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnTopicEndpoint creates a topic endpoint object

  Create a Topic Endpoint object. Any attribute missing from the request will be set to its default value.

A Topic Endpoint attracts messages published to a topic for which the Topic Endpoint has a matching topic subscription. The topic subscription for the Topic Endpoint is specified in the client request to bind a Flow to that Topic Endpoint. Queues are significantly more flexible than Topic Endpoints and are the recommended approach for most applications. The use of Topic Endpoints should be restricted to JMS applications.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
topicEndpointName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) CreateMsgVpnTopicEndpoint(params *CreateMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnTopicEndpointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnTopicEndpointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnTopicEndpoint",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpoints",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnTopicEndpointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnTopicEndpointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnTopicEndpointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateMsgVpnTopicEndpointTemplate creates a topic endpoint template object

  Create a Topic Endpoint Template object. Any attribute missing from the request will be set to its default value.

A Topic Endpoint Template provides a mechanism for specifying the initial state for client created topic endpoints.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x||x|||
topicEndpointTemplateName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) CreateMsgVpnTopicEndpointTemplate(params *CreateMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateMsgVpnTopicEndpointTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMsgVpnTopicEndpointTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createMsgVpnTopicEndpointTemplate",
		Method:             "POST",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpointTemplates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMsgVpnTopicEndpointTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateMsgVpnTopicEndpointTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateMsgVpnTopicEndpointTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateVirtualHostname creates a virtual hostname object

  Create a Virtual Hostname object. Any attribute missing from the request will be set to its default value.

A Virtual Hostname is a provisioned object on a message broker that contains a Virtual Hostname to Message VPN mapping.

Clients which connect to a global (as opposed to per Message VPN) port and provides this hostname will be directed to its corresponding Message VPN. A case-insentive match is performed on the full client-provided hostname against the configured virtual-hostname.

This mechanism is only supported for hostnames provided through the Server Name Indication (SNI) extension of TLS.


Attribute|Identifying|Required|Read-Only|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
virtualHostname|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.17.
*/
func (a *Client) CreateVirtualHostname(params *CreateVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateVirtualHostnameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVirtualHostnameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createVirtualHostname",
		Method:             "POST",
		PathPattern:        "/virtualHostnames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVirtualHostnameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateVirtualHostnameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateVirtualHostnameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteCertAuthority deletes a certificate authority object

  Delete a Certificate Authority object.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.

A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities and domainCertAuthorities.
*/
func (a *Client) DeleteCertAuthority(params *DeleteCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteCertAuthority",
		Method:             "DELETE",
		PathPattern:        "/certAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteCertAuthorityOcspTLSTrustedCommonName deletes an o c s p responder trusted common name object

  Delete an OCSP Responder Trusted Common Name object.

When an OCSP override URL is configured, the OCSP responder will be required to sign the OCSP responses with certificates issued to these Trusted Common Names. A maximum of 8 common names can be configured as valid response signers.

A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities.
*/
func (a *Client) DeleteCertAuthorityOcspTLSTrustedCommonName(params *DeleteCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteCertAuthorityOcspTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCertAuthorityOcspTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteCertAuthorityOcspTlsTrustedCommonName",
		Method:             "DELETE",
		PathPattern:        "/certAuthorities/{certAuthorityName}/ocspTlsTrustedCommonNames/{ocspTlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteCertAuthorityOcspTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteCertAuthorityOcspTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteCertAuthorityOcspTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteClientCertAuthority deletes a client certificate authority object

  Delete a Client Certificate Authority object.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.

A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) DeleteClientCertAuthority(params *DeleteClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClientCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClientCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteClientCertAuthority",
		Method:             "DELETE",
		PathPattern:        "/clientCertAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteClientCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteClientCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteClientCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteClientCertAuthorityOcspTLSTrustedCommonName deletes an o c s p responder trusted common name object

  Delete an OCSP Responder Trusted Common Name object.

When an OCSP override URL is configured, the OCSP responder will be required to sign the OCSP responses with certificates issued to these Trusted Common Names. A maximum of 8 common names can be configured as valid response signers.

A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) DeleteClientCertAuthorityOcspTLSTrustedCommonName(params *DeleteClientCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClientCertAuthorityOcspTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClientCertAuthorityOcspTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteClientCertAuthorityOcspTlsTrustedCommonName",
		Method:             "DELETE",
		PathPattern:        "/clientCertAuthorities/{certAuthorityName}/ocspTlsTrustedCommonNames/{ocspTlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteClientCertAuthorityOcspTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteClientCertAuthorityOcspTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteClientCertAuthorityOcspTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteDmrCluster deletes a cluster object

  Delete a Cluster object.

A Cluster is a provisioned object on a message broker that contains global DMR configuration parameters.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteDmrCluster(params *DeleteDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDmrClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDmrClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDmrCluster",
		Method:             "DELETE",
		PathPattern:        "/dmrClusters/{dmrClusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDmrClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDmrClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteDmrClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteDmrClusterLink deletes a link object

  Delete a Link object.

A Link connects nodes (either within a Cluster or between two different Clusters) and allows them to exchange topology information, subscriptions and data.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteDmrClusterLink(params *DeleteDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDmrClusterLinkOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDmrClusterLinkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDmrClusterLink",
		Method:             "DELETE",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDmrClusterLinkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDmrClusterLinkOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteDmrClusterLinkDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteDmrClusterLinkRemoteAddress deletes a remote address object

  Delete a Remote Address object.

Each Remote Address, consisting of a FQDN or IP address and optional port, is used to connect to the remote node for this Link. Up to 4 addresses may be provided for each Link, and will be tried on a round-robin basis.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteDmrClusterLinkRemoteAddress(params *DeleteDmrClusterLinkRemoteAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDmrClusterLinkRemoteAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDmrClusterLinkRemoteAddressParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDmrClusterLinkRemoteAddress",
		Method:             "DELETE",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}/remoteAddresses/{remoteAddress}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDmrClusterLinkRemoteAddressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDmrClusterLinkRemoteAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteDmrClusterLinkRemoteAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteDmrClusterLinkTLSTrustedCommonName deletes a trusted common name object

  Delete a Trusted Common Name object.

The Trusted Common Names for the Link are used by encrypted transports to verify the name in the certificate presented by the remote node. They must include the common name of the remote node's server certificate or client certificate, depending upon the initiator of the connection.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been deprecated since 2.18. Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) DeleteDmrClusterLinkTLSTrustedCommonName(params *DeleteDmrClusterLinkTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDmrClusterLinkTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDmrClusterLinkTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDmrClusterLinkTlsTrustedCommonName",
		Method:             "DELETE",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}/tlsTrustedCommonNames/{tlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDmrClusterLinkTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDmrClusterLinkTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteDmrClusterLinkTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteDomainCertAuthority deletes a domain certificate authority object

  Delete a Domain Certificate Authority object.

Certificate Authorities trusted for domain verification.

A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) DeleteDomainCertAuthority(params *DeleteDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDomainCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDomainCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDomainCertAuthority",
		Method:             "DELETE",
		PathPattern:        "/domainCertAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDomainCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDomainCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteDomainCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpn deletes a message v p n object

  Delete a Message VPN object.

Message VPNs (Virtual Private Networks) allow for the segregation of topic space and clients. They also group clients connecting to a network of message brokers, such that messages published within a particular group are only visible to that group's clients.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpn(params *DeleteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpn",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnACLProfile deletes an ACL profile object

  Delete an ACL Profile object.

An ACL Profile controls whether an authenticated client is permitted to establish a connection with the message broker or permitted to publish and subscribe to specific topics.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnACLProfile(params *DeleteMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnACLProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAclProfile",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnACLProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnACLProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnACLProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnACLProfileClientConnectException deletes a client connect exception object

  Delete a Client Connect Exception object.

A Client Connect Exception is an exception to the default action to take when a client using the ACL Profile connects to the Message VPN. Exceptions must be expressed as an IP address/netmask in CIDR form.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnACLProfileClientConnectException(params *DeleteMsgVpnACLProfileClientConnectExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileClientConnectExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnACLProfileClientConnectExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAclProfileClientConnectException",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/clientConnectExceptions/{clientConnectExceptionAddress}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnACLProfileClientConnectExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnACLProfileClientConnectExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnACLProfileClientConnectExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnACLProfilePublishException deletes a publish topic exception object

  Delete a Publish Topic Exception object.

A Publish Topic Exception is an exception to the default action to take when a client using the ACL Profile publishes to a topic in the Message VPN. Exceptions must be expressed as a topic.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been deprecated since 2.14. Replaced by publishTopicExceptions.
*/
func (a *Client) DeleteMsgVpnACLProfilePublishException(params *DeleteMsgVpnACLProfilePublishExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfilePublishExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnACLProfilePublishExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAclProfilePublishException",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/publishExceptions/{topicSyntax},{publishExceptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnACLProfilePublishExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnACLProfilePublishExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnACLProfilePublishExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnACLProfilePublishTopicException deletes a publish topic exception object

  Delete a Publish Topic Exception object.

A Publish Topic Exception is an exception to the default action to take when a client using the ACL Profile publishes to a topic in the Message VPN. Exceptions must be expressed as a topic.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) DeleteMsgVpnACLProfilePublishTopicException(params *DeleteMsgVpnACLProfilePublishTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfilePublishTopicExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnACLProfilePublishTopicExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAclProfilePublishTopicException",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/publishTopicExceptions/{publishTopicExceptionSyntax},{publishTopicException}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnACLProfilePublishTopicExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnACLProfilePublishTopicExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnACLProfilePublishTopicExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnACLProfileSubscribeException deletes a subscribe topic exception object

  Delete a Subscribe Topic Exception object.

A Subscribe Topic Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a topic in the Message VPN. Exceptions must be expressed as a topic.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been deprecated since 2.14. Replaced by subscribeTopicExceptions.
*/
func (a *Client) DeleteMsgVpnACLProfileSubscribeException(params *DeleteMsgVpnACLProfileSubscribeExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileSubscribeExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnACLProfileSubscribeExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAclProfileSubscribeException",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeExceptions/{topicSyntax},{subscribeExceptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnACLProfileSubscribeExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnACLProfileSubscribeExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnACLProfileSubscribeExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnACLProfileSubscribeShareNameException deletes a subscribe share name exception object

  Delete a Subscribe Share Name Exception object.

A Subscribe Share Name Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a share-name subscription in the Message VPN. Exceptions must be expressed as a topic.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) DeleteMsgVpnACLProfileSubscribeShareNameException(params *DeleteMsgVpnACLProfileSubscribeShareNameExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileSubscribeShareNameExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnACLProfileSubscribeShareNameExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAclProfileSubscribeShareNameException",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeShareNameExceptions/{subscribeShareNameExceptionSyntax},{subscribeShareNameException}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnACLProfileSubscribeShareNameExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnACLProfileSubscribeShareNameExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnACLProfileSubscribeShareNameExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnACLProfileSubscribeTopicException deletes a subscribe topic exception object

  Delete a Subscribe Topic Exception object.

A Subscribe Topic Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a topic in the Message VPN. Exceptions must be expressed as a topic.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) DeleteMsgVpnACLProfileSubscribeTopicException(params *DeleteMsgVpnACLProfileSubscribeTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnACLProfileSubscribeTopicExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnACLProfileSubscribeTopicExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAclProfileSubscribeTopicException",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeTopicExceptions/{subscribeTopicExceptionSyntax},{subscribeTopicException}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnACLProfileSubscribeTopicExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnACLProfileSubscribeTopicExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnACLProfileSubscribeTopicExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnAuthenticationOauthProvider deletes an o auth provider object

  Delete an OAuth Provider object.

OAuth Providers contain information about the issuer of an OAuth token that is needed to validate the token and derive a client username from it.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.13.
*/
func (a *Client) DeleteMsgVpnAuthenticationOauthProvider(params *DeleteMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnAuthenticationOauthProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnAuthenticationOauthProviderParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAuthenticationOauthProvider",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/authenticationOauthProviders/{oauthProviderName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnAuthenticationOauthProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnAuthenticationOauthProviderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnAuthenticationOauthProviderDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnAuthorizationGroup deletes an l d a p authorization group object

  Delete an LDAP Authorization Group object.

To use client authorization groups configured on an external LDAP server to provide client authorizations, LDAP Authorization Group objects must be created on the Message VPN that match the authorization groups provisioned on the LDAP server. These objects must be configured with the client profiles and ACL profiles that will be assigned to the clients that belong to those authorization groups. A newly created group is placed at the end of the group list which is the lowest priority.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnAuthorizationGroup(params *DeleteMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnAuthorizationGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnAuthorizationGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnAuthorizationGroup",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/authorizationGroups/{authorizationGroupName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnAuthorizationGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnAuthorizationGroupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnAuthorizationGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnBridge deletes a bridge object

  Delete a Bridge object.

Bridges can be used to link two Message VPNs so that messages published to one Message VPN that match the topic subscriptions set for the bridge are also delivered to the linked Message VPN.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnBridge(params *DeleteMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnBridge",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnBridgeRemoteMsgVpn deletes a remote message v p n object

  Delete a Remote Message VPN object.

The Remote Message VPN is the Message VPN that the Bridge connects to.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnBridgeRemoteMsgVpn(params *DeleteMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnBridgeRemoteMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnBridgeRemoteMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnBridgeRemoteMsgVpn",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteMsgVpns/{remoteMsgVpnName},{remoteMsgVpnLocation},{remoteMsgVpnInterface}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnBridgeRemoteMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnBridgeRemoteMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnBridgeRemoteMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnBridgeRemoteSubscription deletes a remote subscription object

  Delete a Remote Subscription object.

A Remote Subscription is a topic subscription used by the Message VPN Bridge to attract messages from the remote message broker.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnBridgeRemoteSubscription(params *DeleteMsgVpnBridgeRemoteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnBridgeRemoteSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnBridgeRemoteSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnBridgeRemoteSubscription",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteSubscriptions/{remoteSubscriptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnBridgeRemoteSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnBridgeRemoteSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnBridgeRemoteSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnBridgeTLSTrustedCommonName deletes a trusted common name object

  Delete a Trusted Common Name object.

The Trusted Common Names for the Bridge are used by encrypted transports to verify the name in the certificate presented by the remote node. They must include the common name of the remote node's server certificate or client certificate, depending upon the initiator of the connection.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been deprecated since 2.18. Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) DeleteMsgVpnBridgeTLSTrustedCommonName(params *DeleteMsgVpnBridgeTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnBridgeTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnBridgeTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnBridgeTlsTrustedCommonName",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/tlsTrustedCommonNames/{tlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnBridgeTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnBridgeTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnBridgeTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnClientProfile deletes a client profile object

  Delete a Client Profile object.

Client Profiles are used to assign common configuration properties to clients that have been successfully authorized.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnClientProfile(params *DeleteMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnClientProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnClientProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnClientProfile",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/clientProfiles/{clientProfileName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnClientProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnClientProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnClientProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnClientUsername deletes a client username object

  Delete a Client Username object.

A client is only authorized to connect to a Message VPN that is associated with a Client Username that the client has been assigned.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnClientUsername(params *DeleteMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnClientUsernameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnClientUsernameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnClientUsername",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/clientUsernames/{clientUsername}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnClientUsernameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnClientUsernameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnClientUsernameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnDistributedCache deletes a distributed cache object

  Delete a Distributed Cache object.

A Distributed Cache is a collection of one or more Cache Clusters that belong to the same Message VPN. Each Cache Cluster in a Distributed Cache is configured to subscribe to a different set of topics. This effectively divides up the configured topic space, to provide scaling to very large topic spaces or very high cached message throughput.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteMsgVpnDistributedCache(params *DeleteMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnDistributedCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnDistributedCache",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnDistributedCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnDistributedCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnDistributedCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnDistributedCacheCluster deletes a cache cluster object

  Delete a Cache Cluster object.

A Cache Cluster is a collection of one or more Cache Instances that subscribe to exactly the same topics. Cache Instances are grouped together in a Cache Cluster for the purpose of fault tolerance and load balancing. As published messages are received, the message broker message bus sends these live data messages to the Cache Instances in the Cache Cluster. This enables client cache requests to be served by any of Cache Instances in the Cache Cluster.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteMsgVpnDistributedCacheCluster(params *DeleteMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnDistributedCacheClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnDistributedCacheCluster",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnDistributedCacheClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnDistributedCacheClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnDistributedCacheClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeCluster deletes a home cache cluster object

  Delete a Home Cache Cluster object.

A Home Cache Cluster is a Cache Cluster that is the "definitive" Cache Cluster for a given topic in the context of the Global Caching feature.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeCluster(params *DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnDistributedCacheClusterGlobalCachingHomeCluster",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/globalCachingHomeClusters/{homeClusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix deletes a topic prefix object

  Delete a Topic Prefix object.

A Topic Prefix is a prefix for a global topic that is available from the containing Home Cache Cluster.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix(params *DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/globalCachingHomeClusters/{homeClusterName}/topicPrefixes/{topicPrefix}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnDistributedCacheClusterInstance deletes a cache instance object

  Delete a Cache Instance object.

A Cache Instance is a single Cache process that belongs to a single Cache Cluster. A Cache Instance object provisioned on the broker is used to disseminate configuration information to the Cache process. Cache Instances listen for and cache live data messages that match the topic subscriptions configured for their parent Cache Cluster.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteMsgVpnDistributedCacheClusterInstance(params *DeleteMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterInstanceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnDistributedCacheClusterInstanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnDistributedCacheClusterInstance",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/instances/{instanceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnDistributedCacheClusterInstanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnDistributedCacheClusterInstanceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnDistributedCacheClusterInstanceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnDistributedCacheClusterTopic deletes a topic object

  Delete a Topic object.

The Cache Instances that belong to the containing Cache Cluster will cache any messages published to topics that match a Topic Subscription.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteMsgVpnDistributedCacheClusterTopic(params *DeleteMsgVpnDistributedCacheClusterTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDistributedCacheClusterTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnDistributedCacheClusterTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnDistributedCacheClusterTopic",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/topics/{topic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnDistributedCacheClusterTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnDistributedCacheClusterTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnDistributedCacheClusterTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnDmrBridge deletes a d m r bridge object

  Delete a DMR Bridge object.

A DMR Bridge is required to establish a data channel over a corresponding external link to the remote node for a given Message VPN. Each DMR Bridge identifies which external link the Message VPN should use, and what the name of the equivalent Message VPN at the remote node is.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteMsgVpnDmrBridge(params *DeleteMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnDmrBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnDmrBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnDmrBridge",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/dmrBridges/{remoteNodeName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnDmrBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnDmrBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnDmrBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnJndiConnectionFactory deletes a j n d i connection factory object

  Delete a JNDI Connection Factory object.

The message broker provides an internal JNDI store for provisioned Connection Factory objects that clients can access through JNDI lookups.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) DeleteMsgVpnJndiConnectionFactory(params *DeleteMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnJndiConnectionFactoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnJndiConnectionFactoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnJndiConnectionFactory",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiConnectionFactories/{connectionFactoryName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnJndiConnectionFactoryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnJndiConnectionFactoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnJndiConnectionFactoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnJndiQueue deletes a j n d i queue object

  Delete a JNDI Queue object.

The message broker provides an internal JNDI store for provisioned Queue objects that clients can access through JNDI lookups.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) DeleteMsgVpnJndiQueue(params *DeleteMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnJndiQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnJndiQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnJndiQueue",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiQueues/{queueName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnJndiQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnJndiQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnJndiQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnJndiTopic deletes a j n d i topic object

  Delete a JNDI Topic object.

The message broker provides an internal JNDI store for provisioned Topic objects that clients can access through JNDI lookups.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) DeleteMsgVpnJndiTopic(params *DeleteMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnJndiTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnJndiTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnJndiTopic",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiTopics/{topicName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnJndiTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnJndiTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnJndiTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnMqttRetainCache deletes an m q t t retain cache object

  Delete an MQTT Retain Cache object.

Using MQTT retained messages allows publishing MQTT clients to indicate that a message must be stored for later delivery to subscribing clients when those subscribing clients add subscriptions matching the retained message's topic. An MQTT Retain Cache processes all retained messages for a Message VPN.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) DeleteMsgVpnMqttRetainCache(params *DeleteMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnMqttRetainCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnMqttRetainCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnMqttRetainCache",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttRetainCaches/{cacheName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnMqttRetainCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnMqttRetainCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnMqttRetainCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnMqttSession deletes an m q t t session object

  Delete an MQTT Session object.

An MQTT Session object is a virtual representation of an MQTT client connection. An MQTT session holds the state of an MQTT client (that is, it is used to contain a client's QoS 0 and QoS 1 subscription sets and any undelivered QoS 1 messages).

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) DeleteMsgVpnMqttSession(params *DeleteMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnMqttSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnMqttSessionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnMqttSession",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnMqttSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnMqttSessionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnMqttSessionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnMqttSessionSubscription deletes a subscription object

  Delete a Subscription object.

An MQTT session contains a client's QoS 0 and QoS 1 subscription sets. On creation, a subscription defaults to QoS 0.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) DeleteMsgVpnMqttSessionSubscription(params *DeleteMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnMqttSessionSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnMqttSessionSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnMqttSessionSubscription",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}/subscriptions/{subscriptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnMqttSessionSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnMqttSessionSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnMqttSessionSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnQueue deletes a queue object

  Delete a Queue object.

A Queue acts as both a destination that clients can publish messages to, and as an endpoint that clients can bind consumers to and consume messages from.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnQueue(params *DeleteMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnQueue",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/queues/{queueName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnQueueSubscription deletes a queue subscription object

  Delete a Queue Subscription object.

One or more Queue Subscriptions can be added to a durable queue so that Guaranteed messages published to matching topics are also delivered to and spooled by the queue.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnQueueSubscription(params *DeleteMsgVpnQueueSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnQueueSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnQueueSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnQueueSubscription",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/queues/{queueName}/subscriptions/{subscriptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnQueueSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnQueueSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnQueueSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnQueueTemplate deletes a queue template object

  Delete a Queue Template object.

A Queue Template provides a mechanism for specifying the initial state for client created queues.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) DeleteMsgVpnQueueTemplate(params *DeleteMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnQueueTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnQueueTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnQueueTemplate",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/queueTemplates/{queueTemplateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnQueueTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnQueueTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnQueueTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnReplayLog deletes a replay log object

  Delete a Replay Log object.

When the Message Replay feature is enabled, message brokers store persistent messages in a Replay Log. These messages are kept until the log is full, after which the oldest messages are removed to free up space for new messages.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.10.
*/
func (a *Client) DeleteMsgVpnReplayLog(params *DeleteMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnReplayLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnReplayLogParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnReplayLog",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/replayLogs/{replayLogName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnReplayLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnReplayLogOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnReplayLogDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnReplicatedTopic deletes a replicated topic object

  Delete a Replicated Topic object.

To indicate which messages should be replicated between the active and standby site, a Replicated Topic subscription must be configured on a Message VPN. If a published message matches both a replicated topic and an endpoint on the active site, then the message is replicated to the standby site.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) DeleteMsgVpnReplicatedTopic(params *DeleteMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnReplicatedTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnReplicatedTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnReplicatedTopic",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/replicatedTopics/{replicatedTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnReplicatedTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnReplicatedTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnReplicatedTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnRestDeliveryPoint deletes a r e s t delivery point object

  Delete a REST Delivery Point object.

A REST Delivery Point manages delivery of messages from queues to a named list of REST Consumers.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnRestDeliveryPoint(params *DeleteMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnRestDeliveryPointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnRestDeliveryPoint",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnRestDeliveryPointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnRestDeliveryPointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnRestDeliveryPointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnRestDeliveryPointQueueBinding deletes a queue binding object

  Delete a Queue Binding object.

A Queue Binding for a REST Delivery Point attracts messages to be delivered to REST consumers. If the queue does not exist it can be created subsequently, and once the queue is operational the broker performs the queue binding. Removing the queue binding does not delete the queue itself. Similarly, removing the queue does not remove the queue binding, which fails until the queue is recreated or the queue binding is deleted.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnRestDeliveryPointQueueBinding(params *DeleteMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointQueueBindingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnRestDeliveryPointQueueBindingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnRestDeliveryPointQueueBinding",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/queueBindings/{queueBindingName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnRestDeliveryPointQueueBindingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnRestDeliveryPointQueueBindingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnRestDeliveryPointQueueBindingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnRestDeliveryPointRestConsumer deletes a r e s t consumer object

  Delete a REST Consumer object.

REST Consumer objects establish HTTP connectivity to REST consumer applications who wish to receive messages from a broker.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnRestDeliveryPointRestConsumer(params *DeleteMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointRestConsumerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnRestDeliveryPointRestConsumerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnRestDeliveryPointRestConsumer",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnRestDeliveryPointRestConsumerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnRestDeliveryPointRestConsumerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnRestDeliveryPointRestConsumerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim deletes a claim object

  Delete a Claim object.

A Claim is added to the JWT sent to the OAuth token request endpoint.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.21.
*/
func (a *Client) DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim(params *DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}/oauthJwtClaims/{oauthJwtClaimName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName deletes a trusted common name object

  Delete a Trusted Common Name object.

The Trusted Common Names for the REST Consumer are used by encrypted transports to verify the name in the certificate presented by the remote REST consumer. They must include the common name of the remote REST consumer's server certificate.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been deprecated since (will be deprecated in next SEMP version). Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName(params *DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnRestDeliveryPointRestConsumerTlsTrustedCommonName",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}/tlsTrustedCommonNames/{tlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnSequencedTopic deletes a sequenced topic object

  Delete a Sequenced Topic object.

A Sequenced Topic is a topic subscription for which any matching messages received on the Message VPN are assigned a sequence number that is monotonically increased by a value of one per message.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) DeleteMsgVpnSequencedTopic(params *DeleteMsgVpnSequencedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnSequencedTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnSequencedTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnSequencedTopic",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/sequencedTopics/{sequencedTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnSequencedTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnSequencedTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnSequencedTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnTopicEndpoint deletes a topic endpoint object

  Delete a Topic Endpoint object.

A Topic Endpoint attracts messages published to a topic for which the Topic Endpoint has a matching topic subscription. The topic subscription for the Topic Endpoint is specified in the client request to bind a Flow to that Topic Endpoint. Queues are significantly more flexible than Topic Endpoints and are the recommended approach for most applications. The use of Topic Endpoints should be restricted to JMS applications.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) DeleteMsgVpnTopicEndpoint(params *DeleteMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnTopicEndpointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnTopicEndpointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnTopicEndpoint",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpoints/{topicEndpointName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnTopicEndpointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnTopicEndpointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnTopicEndpointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteMsgVpnTopicEndpointTemplate deletes a topic endpoint template object

  Delete a Topic Endpoint Template object.

A Topic Endpoint Template provides a mechanism for specifying the initial state for client created topic endpoints.

A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) DeleteMsgVpnTopicEndpointTemplate(params *DeleteMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteMsgVpnTopicEndpointTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMsgVpnTopicEndpointTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteMsgVpnTopicEndpointTemplate",
		Method:             "DELETE",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpointTemplates/{topicEndpointTemplateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMsgVpnTopicEndpointTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteMsgVpnTopicEndpointTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteMsgVpnTopicEndpointTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteVirtualHostname deletes a virtual hostname object

  Delete a Virtual Hostname object.

A Virtual Hostname is a provisioned object on a message broker that contains a Virtual Hostname to Message VPN mapping.

Clients which connect to a global (as opposed to per Message VPN) port and provides this hostname will be directed to its corresponding Message VPN. A case-insentive match is performed on the full client-provided hostname against the configured virtual-hostname.

This mechanism is only supported for hostnames provided through the Server Name Indication (SNI) extension of TLS.

A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.17.
*/
func (a *Client) DeleteVirtualHostname(params *DeleteVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteVirtualHostnameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteVirtualHostnameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteVirtualHostname",
		Method:             "DELETE",
		PathPattern:        "/virtualHostnames/{virtualHostname}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteVirtualHostnameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteVirtualHostnameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteVirtualHostnameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetAbout gets an about object

  Get an About object.

This provides metadata about the SEMP API, such as the version of the API supported by the broker.



A SEMP client authorized with a minimum access scope/level of "global/none" is required to perform this operation.

This has been available since 2.13.
*/
func (a *Client) GetAbout(params *GetAboutParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAboutParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAbout",
		Method:             "GET",
		PathPattern:        "/about",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAboutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAboutOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAboutDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetAboutAPI gets an API description object

  Get an API Description object.

The API Description object provides metadata about the SEMP API.



A SEMP client authorized with a minimum access scope/level of "global/none" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetAboutAPI(params *GetAboutAPIParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutAPIOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAboutAPIParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAboutApi",
		Method:             "GET",
		PathPattern:        "/about/api",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAboutAPIReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAboutAPIOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAboutAPIDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetAboutUser gets a user object

  Get a User object.

Session and access level information about the user accessing the SEMP API.



A SEMP client authorized with a minimum access scope/level of "global/none" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetAboutUser(params *GetAboutUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAboutUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAboutUser",
		Method:             "GET",
		PathPattern:        "/about/user",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAboutUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAboutUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAboutUserDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetAboutUserMsgVpn gets a user message v p n object

  Get a User Message VPN object.

This provides information about the Message VPN access level for the username used to access the SEMP API.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "global/none" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetAboutUserMsgVpn(params *GetAboutUserMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutUserMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAboutUserMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAboutUserMsgVpn",
		Method:             "GET",
		PathPattern:        "/about/user/msgVpns/{msgVpnName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAboutUserMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAboutUserMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAboutUserMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetAboutUserMsgVpns gets a list of user message v p n objects

  Get a list of User Message VPN objects.

This provides information about the Message VPN access level for the username used to access the SEMP API.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "global/none" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetAboutUserMsgVpns(params *GetAboutUserMsgVpnsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAboutUserMsgVpnsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAboutUserMsgVpnsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAboutUserMsgVpns",
		Method:             "GET",
		PathPattern:        "/about/user/msgVpns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAboutUserMsgVpnsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAboutUserMsgVpnsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAboutUserMsgVpnsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetBroker gets a broker object

  Get a Broker object.

This object contains global configuration for the message broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
tlsServerCertContent||x||x
tlsServerCertPassword||x||



A SEMP client authorized with a minimum access scope/level of "global/none" is required to perform this operation. Requests which include the following attributes require greater access scope/level:


Attribute|Access Scope/Level
:---|:---:
guaranteedMsgingEnabled|global/read-only
guaranteedMsgingEventCacheUsageThreshold.clearPercent|global/read-only
guaranteedMsgingEventCacheUsageThreshold.clearValue|global/read-only
guaranteedMsgingEventCacheUsageThreshold.setPercent|global/read-only
guaranteedMsgingEventCacheUsageThreshold.setValue|global/read-only
guaranteedMsgingEventDeliveredUnackedThreshold.clearPercent|global/read-only
guaranteedMsgingEventDeliveredUnackedThreshold.setPercent|global/read-only
guaranteedMsgingEventDiskUsageThreshold.clearPercent|global/read-only
guaranteedMsgingEventDiskUsageThreshold.setPercent|global/read-only
guaranteedMsgingEventEgressFlowCountThreshold.clearPercent|global/read-only
guaranteedMsgingEventEgressFlowCountThreshold.clearValue|global/read-only
guaranteedMsgingEventEgressFlowCountThreshold.setPercent|global/read-only
guaranteedMsgingEventEgressFlowCountThreshold.setValue|global/read-only
guaranteedMsgingEventEndpointCountThreshold.clearPercent|global/read-only
guaranteedMsgingEventEndpointCountThreshold.clearValue|global/read-only
guaranteedMsgingEventEndpointCountThreshold.setPercent|global/read-only
guaranteedMsgingEventEndpointCountThreshold.setValue|global/read-only
guaranteedMsgingEventIngressFlowCountThreshold.clearPercent|global/read-only
guaranteedMsgingEventIngressFlowCountThreshold.clearValue|global/read-only
guaranteedMsgingEventIngressFlowCountThreshold.setPercent|global/read-only
guaranteedMsgingEventIngressFlowCountThreshold.setValue|global/read-only
guaranteedMsgingEventMsgCountThreshold.clearPercent|global/read-only
guaranteedMsgingEventMsgCountThreshold.setPercent|global/read-only
guaranteedMsgingEventMsgSpoolFileCountThreshold.clearPercent|global/read-only
guaranteedMsgingEventMsgSpoolFileCountThreshold.setPercent|global/read-only
guaranteedMsgingEventMsgSpoolUsageThreshold.clearPercent|global/read-only
guaranteedMsgingEventMsgSpoolUsageThreshold.clearValue|global/read-only
guaranteedMsgingEventMsgSpoolUsageThreshold.setPercent|global/read-only
guaranteedMsgingEventMsgSpoolUsageThreshold.setValue|global/read-only
guaranteedMsgingEventTransactedSessionCountThreshold.clearPercent|global/read-only
guaranteedMsgingEventTransactedSessionCountThreshold.clearValue|global/read-only
guaranteedMsgingEventTransactedSessionCountThreshold.setPercent|global/read-only
guaranteedMsgingEventTransactedSessionCountThreshold.setValue|global/read-only
guaranteedMsgingEventTransactedSessionResourceCountThreshold.clearPercent|global/read-only
guaranteedMsgingEventTransactedSessionResourceCountThreshold.setPercent|global/read-only
guaranteedMsgingEventTransactionCountThreshold.clearPercent|global/read-only
guaranteedMsgingEventTransactionCountThreshold.clearValue|global/read-only
guaranteedMsgingEventTransactionCountThreshold.setPercent|global/read-only
guaranteedMsgingEventTransactionCountThreshold.setValue|global/read-only
guaranteedMsgingMaxCacheUsage|global/read-only
guaranteedMsgingMaxMsgSpoolUsage|global/read-only
guaranteedMsgingMsgSpoolSyncMirroredMsgAckTimeout|global/read-only
guaranteedMsgingMsgSpoolSyncMirroredSpoolFileAckTimeout|global/read-only
guaranteedMsgingTransactionReplicationCompatibilityMode|global/read-only
serviceAmqpEnabled|global/read-only
serviceAmqpTlsListenPort|global/read-only
serviceEventConnectionCountThreshold.clearPercent|global/read-only
serviceEventConnectionCountThreshold.clearValue|global/read-only
serviceEventConnectionCountThreshold.setPercent|global/read-only
serviceEventConnectionCountThreshold.setValue|global/read-only
serviceHealthCheckEnabled|global/read-only
serviceHealthCheckListenPort|global/read-only
serviceMateLinkEnabled|global/read-only
serviceMateLinkListenPort|global/read-only
serviceMqttEnabled|global/read-only
serviceMsgBackboneEnabled|global/read-only
serviceRedundancyEnabled|global/read-only
serviceRedundancyFirstListenPort|global/read-only
serviceRestEventOutgoingConnectionCountThreshold.clearPercent|global/read-only
serviceRestEventOutgoingConnectionCountThreshold.clearValue|global/read-only
serviceRestEventOutgoingConnectionCountThreshold.setPercent|global/read-only
serviceRestEventOutgoingConnectionCountThreshold.setValue|global/read-only
serviceRestIncomingEnabled|global/read-only
serviceRestOutgoingEnabled|global/read-only
serviceSempLegacyTimeoutEnabled|global/read-only
serviceSempPlainTextEnabled|global/read-only
serviceSempPlainTextListenPort|global/read-only
serviceSempSessionIdleTimeout|global/read-only
serviceSempSessionMaxLifetime|global/read-only
serviceSempTlsEnabled|global/read-only
serviceSempTlsListenPort|global/read-only
serviceSmfCompressionListenPort|global/read-only
serviceSmfEnabled|global/read-only
serviceSmfEventConnectionCountThreshold.clearPercent|global/read-only
serviceSmfEventConnectionCountThreshold.clearValue|global/read-only
serviceSmfEventConnectionCountThreshold.setPercent|global/read-only
serviceSmfEventConnectionCountThreshold.setValue|global/read-only
serviceSmfPlainTextListenPort|global/read-only
serviceSmfRoutingControlListenPort|global/read-only
serviceSmfTlsListenPort|global/read-only
serviceTlsEventConnectionCountThreshold.clearPercent|global/read-only
serviceTlsEventConnectionCountThreshold.clearValue|global/read-only
serviceTlsEventConnectionCountThreshold.setPercent|global/read-only
serviceTlsEventConnectionCountThreshold.setValue|global/read-only
serviceWebTransportEnabled|global/read-only
serviceWebTransportPlainTextListenPort|global/read-only
serviceWebTransportTlsListenPort|global/read-only
serviceWebTransportWebUrlSuffix|global/read-only
tlsBlockVersion11Enabled|global/read-only
tlsCipherSuiteManagementList|global/read-only
tlsCipherSuiteMsgBackboneList|global/read-only
tlsCipherSuiteSecureShellList|global/read-only
tlsCrimeExploitProtectionEnabled|global/read-only
tlsServerCertContent|global/read-only
tlsStandardDomainCertificateAuthoritiesEnabled|vpn/read-only
tlsTicketLifetime|global/read-only



This has been available since 2.13.
*/
func (a *Client) GetBroker(params *GetBrokerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBrokerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBrokerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getBroker",
		Method:             "GET",
		PathPattern:        "/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetBrokerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetBrokerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetBrokerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetCertAuthorities gets a list of certificate authority objects

  Get a list of Certificate Authority objects.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x||x|
certContent|||x|
crlDayList|||x|
crlTimeList|||x|
crlUrl|||x|
ocspNonResponderCertEnabled|||x|
ocspOverrideUrl|||x|
ocspTimeout|||x|
revocationCheckEnabled|||x|



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities and domainCertAuthorities.
*/
func (a *Client) GetCertAuthorities(params *GetCertAuthoritiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCertAuthoritiesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCertAuthoritiesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getCertAuthorities",
		Method:             "GET",
		PathPattern:        "/certAuthorities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCertAuthoritiesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetCertAuthoritiesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetCertAuthoritiesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetCertAuthority gets a certificate authority object

  Get a Certificate Authority object.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x||x|
certContent|||x|
crlDayList|||x|
crlTimeList|||x|
crlUrl|||x|
ocspNonResponderCertEnabled|||x|
ocspOverrideUrl|||x|
ocspTimeout|||x|
revocationCheckEnabled|||x|



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities and domainCertAuthorities.
*/
func (a *Client) GetCertAuthority(params *GetCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getCertAuthority",
		Method:             "GET",
		PathPattern:        "/certAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetCertAuthorityOcspTLSTrustedCommonName gets an o c s p responder trusted common name object

  Get an OCSP Responder Trusted Common Name object.

When an OCSP override URL is configured, the OCSP responder will be required to sign the OCSP responses with certificates issued to these Trusted Common Names. A maximum of 8 common names can be configured as valid response signers.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x||x|
ocspTlsTrustedCommonName|x||x|



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities.
*/
func (a *Client) GetCertAuthorityOcspTLSTrustedCommonName(params *GetCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCertAuthorityOcspTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCertAuthorityOcspTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getCertAuthorityOcspTlsTrustedCommonName",
		Method:             "GET",
		PathPattern:        "/certAuthorities/{certAuthorityName}/ocspTlsTrustedCommonNames/{ocspTlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCertAuthorityOcspTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetCertAuthorityOcspTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetCertAuthorityOcspTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetCertAuthorityOcspTLSTrustedCommonNames gets a list of o c s p responder trusted common name objects

  Get a list of OCSP Responder Trusted Common Name objects.

When an OCSP override URL is configured, the OCSP responder will be required to sign the OCSP responses with certificates issued to these Trusted Common Names. A maximum of 8 common names can be configured as valid response signers.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x||x|
ocspTlsTrustedCommonName|x||x|



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities.
*/
func (a *Client) GetCertAuthorityOcspTLSTrustedCommonNames(params *GetCertAuthorityOcspTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCertAuthorityOcspTLSTrustedCommonNamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCertAuthorityOcspTLSTrustedCommonNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getCertAuthorityOcspTlsTrustedCommonNames",
		Method:             "GET",
		PathPattern:        "/certAuthorities/{certAuthorityName}/ocspTlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCertAuthorityOcspTLSTrustedCommonNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetCertAuthorityOcspTLSTrustedCommonNamesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetCertAuthorityOcspTLSTrustedCommonNamesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetClientCertAuthorities gets a list of client certificate authority objects

  Get a list of Client Certificate Authority objects.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) GetClientCertAuthorities(params *GetClientCertAuthoritiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientCertAuthoritiesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClientCertAuthoritiesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getClientCertAuthorities",
		Method:             "GET",
		PathPattern:        "/clientCertAuthorities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetClientCertAuthoritiesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClientCertAuthoritiesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClientCertAuthoritiesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetClientCertAuthority gets a client certificate authority object

  Get a Client Certificate Authority object.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) GetClientCertAuthority(params *GetClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClientCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getClientCertAuthority",
		Method:             "GET",
		PathPattern:        "/clientCertAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetClientCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClientCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClientCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetClientCertAuthorityOcspTLSTrustedCommonName gets an o c s p responder trusted common name object

  Get an OCSP Responder Trusted Common Name object.

When an OCSP override URL is configured, the OCSP responder will be required to sign the OCSP responses with certificates issued to these Trusted Common Names. A maximum of 8 common names can be configured as valid response signers.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x|||
ocspTlsTrustedCommonName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) GetClientCertAuthorityOcspTLSTrustedCommonName(params *GetClientCertAuthorityOcspTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientCertAuthorityOcspTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClientCertAuthorityOcspTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getClientCertAuthorityOcspTlsTrustedCommonName",
		Method:             "GET",
		PathPattern:        "/clientCertAuthorities/{certAuthorityName}/ocspTlsTrustedCommonNames/{ocspTlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetClientCertAuthorityOcspTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClientCertAuthorityOcspTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClientCertAuthorityOcspTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetClientCertAuthorityOcspTLSTrustedCommonNames gets a list of o c s p responder trusted common name objects

  Get a list of OCSP Responder Trusted Common Name objects.

When an OCSP override URL is configured, the OCSP responder will be required to sign the OCSP responses with certificates issued to these Trusted Common Names. A maximum of 8 common names can be configured as valid response signers.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x|||
ocspTlsTrustedCommonName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) GetClientCertAuthorityOcspTLSTrustedCommonNames(params *GetClientCertAuthorityOcspTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientCertAuthorityOcspTLSTrustedCommonNamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClientCertAuthorityOcspTLSTrustedCommonNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getClientCertAuthorityOcspTlsTrustedCommonNames",
		Method:             "GET",
		PathPattern:        "/clientCertAuthorities/{certAuthorityName}/ocspTlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetClientCertAuthorityOcspTLSTrustedCommonNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClientCertAuthorityOcspTLSTrustedCommonNamesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClientCertAuthorityOcspTLSTrustedCommonNamesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDmrCluster gets a cluster object

  Get a Cluster object.

A Cluster is a provisioned object on a message broker that contains global DMR configuration parameters.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
authenticationBasicPassword||x||x
authenticationClientCertContent||x||x
authenticationClientCertPassword||x||
dmrClusterName|x|||
tlsServerCertEnforceTrustedCommonNameEnabled|||x|



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetDmrCluster(params *GetDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDmrClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDmrCluster",
		Method:             "GET",
		PathPattern:        "/dmrClusters/{dmrClusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDmrClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDmrClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDmrClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDmrClusterLink gets a link object

  Get a Link object.

A Link connects nodes (either within a Cluster or between two different Clusters) and allows them to exchange topology information, subscriptions and data.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
authenticationBasicPassword||x||x
dmrClusterName|x|||
remoteNodeName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetDmrClusterLink(params *GetDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDmrClusterLinkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDmrClusterLink",
		Method:             "GET",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDmrClusterLinkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDmrClusterLinkOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDmrClusterLinkDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDmrClusterLinkRemoteAddress gets a remote address object

  Get a Remote Address object.

Each Remote Address, consisting of a FQDN or IP address and optional port, is used to connect to the remote node for this Link. Up to 4 addresses may be provided for each Link, and will be tried on a round-robin basis.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
dmrClusterName|x|||
remoteAddress|x|||
remoteNodeName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetDmrClusterLinkRemoteAddress(params *GetDmrClusterLinkRemoteAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkRemoteAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDmrClusterLinkRemoteAddressParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDmrClusterLinkRemoteAddress",
		Method:             "GET",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}/remoteAddresses/{remoteAddress}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDmrClusterLinkRemoteAddressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDmrClusterLinkRemoteAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDmrClusterLinkRemoteAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDmrClusterLinkRemoteAddresses gets a list of remote address objects

  Get a list of Remote Address objects.

Each Remote Address, consisting of a FQDN or IP address and optional port, is used to connect to the remote node for this Link. Up to 4 addresses may be provided for each Link, and will be tried on a round-robin basis.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
dmrClusterName|x|||
remoteAddress|x|||
remoteNodeName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetDmrClusterLinkRemoteAddresses(params *GetDmrClusterLinkRemoteAddressesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkRemoteAddressesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDmrClusterLinkRemoteAddressesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDmrClusterLinkRemoteAddresses",
		Method:             "GET",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}/remoteAddresses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDmrClusterLinkRemoteAddressesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDmrClusterLinkRemoteAddressesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDmrClusterLinkRemoteAddressesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDmrClusterLinkTLSTrustedCommonName gets a trusted common name object

  Get a Trusted Common Name object.

The Trusted Common Names for the Link are used by encrypted transports to verify the name in the certificate presented by the remote node. They must include the common name of the remote node's server certificate or client certificate, depending upon the initiator of the connection.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
dmrClusterName|x||x|
remoteNodeName|x||x|
tlsTrustedCommonName|x||x|



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been deprecated since 2.18. Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) GetDmrClusterLinkTLSTrustedCommonName(params *GetDmrClusterLinkTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDmrClusterLinkTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDmrClusterLinkTlsTrustedCommonName",
		Method:             "GET",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}/tlsTrustedCommonNames/{tlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDmrClusterLinkTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDmrClusterLinkTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDmrClusterLinkTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDmrClusterLinkTLSTrustedCommonNames gets a list of trusted common name objects

  Get a list of Trusted Common Name objects.

The Trusted Common Names for the Link are used by encrypted transports to verify the name in the certificate presented by the remote node. They must include the common name of the remote node's server certificate or client certificate, depending upon the initiator of the connection.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
dmrClusterName|x||x|
remoteNodeName|x||x|
tlsTrustedCommonName|x||x|



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been deprecated since 2.18. Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) GetDmrClusterLinkTLSTrustedCommonNames(params *GetDmrClusterLinkTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinkTLSTrustedCommonNamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDmrClusterLinkTLSTrustedCommonNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDmrClusterLinkTlsTrustedCommonNames",
		Method:             "GET",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}/tlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDmrClusterLinkTLSTrustedCommonNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDmrClusterLinkTLSTrustedCommonNamesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDmrClusterLinkTLSTrustedCommonNamesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDmrClusterLinks gets a list of link objects

  Get a list of Link objects.

A Link connects nodes (either within a Cluster or between two different Clusters) and allows them to exchange topology information, subscriptions and data.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
authenticationBasicPassword||x||x
dmrClusterName|x|||
remoteNodeName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetDmrClusterLinks(params *GetDmrClusterLinksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClusterLinksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDmrClusterLinksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDmrClusterLinks",
		Method:             "GET",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDmrClusterLinksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDmrClusterLinksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDmrClusterLinksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDmrClusters gets a list of cluster objects

  Get a list of Cluster objects.

A Cluster is a provisioned object on a message broker that contains global DMR configuration parameters.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
authenticationBasicPassword||x||x
authenticationClientCertContent||x||x
authenticationClientCertPassword||x||
dmrClusterName|x|||
tlsServerCertEnforceTrustedCommonNameEnabled|||x|



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetDmrClusters(params *GetDmrClustersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDmrClustersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDmrClustersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDmrClusters",
		Method:             "GET",
		PathPattern:        "/dmrClusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDmrClustersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDmrClustersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDmrClustersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDomainCertAuthorities gets a list of domain certificate authority objects

  Get a list of Domain Certificate Authority objects.

Certificate Authorities trusted for domain verification.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) GetDomainCertAuthorities(params *GetDomainCertAuthoritiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDomainCertAuthoritiesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDomainCertAuthoritiesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDomainCertAuthorities",
		Method:             "GET",
		PathPattern:        "/domainCertAuthorities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDomainCertAuthoritiesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDomainCertAuthoritiesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDomainCertAuthoritiesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetDomainCertAuthority gets a domain certificate authority object

  Get a Domain Certificate Authority object.

Certificate Authorities trusted for domain verification.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
certAuthorityName|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) GetDomainCertAuthority(params *GetDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDomainCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDomainCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDomainCertAuthority",
		Method:             "GET",
		PathPattern:        "/domainCertAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDomainCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDomainCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDomainCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpn gets a message v p n object

  Get a Message VPN object.

Message VPNs (Virtual Private Networks) allow for the segregation of topic space and clients. They also group clients connecting to a network of message brokers, such that messages published within a particular group are only visible to that group's clients.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgingTlsServerCertEnforceTrustedCommonNameEnabled|||x|
msgVpnName|x|||
replicationBridgeAuthenticationBasicPassword||x||x
replicationBridgeAuthenticationClientCertContent||x||x
replicationBridgeAuthenticationClientCertPassword||x||
replicationEnabledQueueBehavior||x||
restTlsServerCertEnforceTrustedCommonNameEnabled|||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpn(params *GetMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpn",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfile gets an ACL profile object

  Get an ACL Profile object.

An ACL Profile controls whether an authenticated client is permitted to establish a connection with the message broker or permitted to publish and subscribe to specific topics.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnACLProfile(params *GetMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfile",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfileClientConnectException gets a client connect exception object

  Get a Client Connect Exception object.

A Client Connect Exception is an exception to the default action to take when a client using the ACL Profile connects to the Message VPN. Exceptions must be expressed as an IP address/netmask in CIDR form.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
clientConnectExceptionAddress|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnACLProfileClientConnectException(params *GetMsgVpnACLProfileClientConnectExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileClientConnectExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileClientConnectExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfileClientConnectException",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/clientConnectExceptions/{clientConnectExceptionAddress}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileClientConnectExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileClientConnectExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileClientConnectExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfileClientConnectExceptions gets a list of client connect exception objects

  Get a list of Client Connect Exception objects.

A Client Connect Exception is an exception to the default action to take when a client using the ACL Profile connects to the Message VPN. Exceptions must be expressed as an IP address/netmask in CIDR form.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
clientConnectExceptionAddress|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnACLProfileClientConnectExceptions(params *GetMsgVpnACLProfileClientConnectExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileClientConnectExceptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileClientConnectExceptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfileClientConnectExceptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/clientConnectExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileClientConnectExceptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileClientConnectExceptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileClientConnectExceptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfilePublishException gets a publish topic exception object

  Get a Publish Topic Exception object.

A Publish Topic Exception is an exception to the default action to take when a client using the ACL Profile publishes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x||x|
msgVpnName|x||x|
publishExceptionTopic|x||x|
topicSyntax|x||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been deprecated since 2.14. Replaced by publishTopicExceptions.
*/
func (a *Client) GetMsgVpnACLProfilePublishException(params *GetMsgVpnACLProfilePublishExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilePublishExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfilePublishExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfilePublishException",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/publishExceptions/{topicSyntax},{publishExceptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfilePublishExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfilePublishExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfilePublishExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfilePublishExceptions gets a list of publish topic exception objects

  Get a list of Publish Topic Exception objects.

A Publish Topic Exception is an exception to the default action to take when a client using the ACL Profile publishes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x||x|
msgVpnName|x||x|
publishExceptionTopic|x||x|
topicSyntax|x||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been deprecated since 2.14. Replaced by publishTopicExceptions.
*/
func (a *Client) GetMsgVpnACLProfilePublishExceptions(params *GetMsgVpnACLProfilePublishExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilePublishExceptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfilePublishExceptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfilePublishExceptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/publishExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfilePublishExceptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfilePublishExceptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfilePublishExceptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfilePublishTopicException gets a publish topic exception object

  Get a Publish Topic Exception object.

A Publish Topic Exception is an exception to the default action to take when a client using the ACL Profile publishes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
msgVpnName|x|||
publishTopicException|x|||
publishTopicExceptionSyntax|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnACLProfilePublishTopicException(params *GetMsgVpnACLProfilePublishTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilePublishTopicExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfilePublishTopicExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfilePublishTopicException",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/publishTopicExceptions/{publishTopicExceptionSyntax},{publishTopicException}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfilePublishTopicExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfilePublishTopicExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfilePublishTopicExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfilePublishTopicExceptions gets a list of publish topic exception objects

  Get a list of Publish Topic Exception objects.

A Publish Topic Exception is an exception to the default action to take when a client using the ACL Profile publishes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
msgVpnName|x|||
publishTopicException|x|||
publishTopicExceptionSyntax|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnACLProfilePublishTopicExceptions(params *GetMsgVpnACLProfilePublishTopicExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilePublishTopicExceptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfilePublishTopicExceptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfilePublishTopicExceptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/publishTopicExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfilePublishTopicExceptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfilePublishTopicExceptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfilePublishTopicExceptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfileSubscribeException gets a subscribe topic exception object

  Get a Subscribe Topic Exception object.

A Subscribe Topic Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x||x|
msgVpnName|x||x|
subscribeExceptionTopic|x||x|
topicSyntax|x||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been deprecated since 2.14. Replaced by subscribeTopicExceptions.
*/
func (a *Client) GetMsgVpnACLProfileSubscribeException(params *GetMsgVpnACLProfileSubscribeExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileSubscribeExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfileSubscribeException",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeExceptions/{topicSyntax},{subscribeExceptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileSubscribeExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileSubscribeExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileSubscribeExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfileSubscribeExceptions gets a list of subscribe topic exception objects

  Get a list of Subscribe Topic Exception objects.

A Subscribe Topic Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x||x|
msgVpnName|x||x|
subscribeExceptionTopic|x||x|
topicSyntax|x||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been deprecated since 2.14. Replaced by subscribeTopicExceptions.
*/
func (a *Client) GetMsgVpnACLProfileSubscribeExceptions(params *GetMsgVpnACLProfileSubscribeExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeExceptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileSubscribeExceptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfileSubscribeExceptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileSubscribeExceptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileSubscribeExceptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileSubscribeExceptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfileSubscribeShareNameException gets a subscribe share name exception object

  Get a Subscribe Share Name Exception object.

A Subscribe Share Name Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a share-name subscription in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
msgVpnName|x|||
subscribeShareNameException|x|||
subscribeShareNameExceptionSyntax|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnACLProfileSubscribeShareNameException(params *GetMsgVpnACLProfileSubscribeShareNameExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeShareNameExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileSubscribeShareNameExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfileSubscribeShareNameException",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeShareNameExceptions/{subscribeShareNameExceptionSyntax},{subscribeShareNameException}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileSubscribeShareNameExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileSubscribeShareNameExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileSubscribeShareNameExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfileSubscribeShareNameExceptions gets a list of subscribe share name exception objects

  Get a list of Subscribe Share Name Exception objects.

A Subscribe Share Name Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a share-name subscription in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
msgVpnName|x|||
subscribeShareNameException|x|||
subscribeShareNameExceptionSyntax|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnACLProfileSubscribeShareNameExceptions(params *GetMsgVpnACLProfileSubscribeShareNameExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeShareNameExceptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileSubscribeShareNameExceptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfileSubscribeShareNameExceptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeShareNameExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileSubscribeShareNameExceptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileSubscribeShareNameExceptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileSubscribeShareNameExceptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfileSubscribeTopicException gets a subscribe topic exception object

  Get a Subscribe Topic Exception object.

A Subscribe Topic Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
msgVpnName|x|||
subscribeTopicException|x|||
subscribeTopicExceptionSyntax|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnACLProfileSubscribeTopicException(params *GetMsgVpnACLProfileSubscribeTopicExceptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeTopicExceptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileSubscribeTopicExceptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfileSubscribeTopicException",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeTopicExceptions/{subscribeTopicExceptionSyntax},{subscribeTopicException}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileSubscribeTopicExceptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileSubscribeTopicExceptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileSubscribeTopicExceptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfileSubscribeTopicExceptions gets a list of subscribe topic exception objects

  Get a list of Subscribe Topic Exception objects.

A Subscribe Topic Exception is an exception to the default action to take when a client using the ACL Profile subscribes to a topic in the Message VPN. Exceptions must be expressed as a topic.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
msgVpnName|x|||
subscribeTopicException|x|||
subscribeTopicExceptionSyntax|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnACLProfileSubscribeTopicExceptions(params *GetMsgVpnACLProfileSubscribeTopicExceptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfileSubscribeTopicExceptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfileSubscribeTopicExceptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfileSubscribeTopicExceptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}/subscribeTopicExceptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfileSubscribeTopicExceptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfileSubscribeTopicExceptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfileSubscribeTopicExceptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnACLProfiles gets a list of ACL profile objects

  Get a list of ACL Profile objects.

An ACL Profile controls whether an authenticated client is permitted to establish a connection with the message broker or permitted to publish and subscribe to specific topics.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
aclProfileName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnACLProfiles(params *GetMsgVpnACLProfilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnACLProfilesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnACLProfilesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAclProfiles",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnACLProfilesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnACLProfilesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnACLProfilesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnAuthenticationOauthProvider gets an o auth provider object

  Get an OAuth Provider object.

OAuth Providers contain information about the issuer of an OAuth token that is needed to validate the token and derive a client username from it.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
oauthProviderName|x|||
tokenIntrospectionPassword||x||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.13.
*/
func (a *Client) GetMsgVpnAuthenticationOauthProvider(params *GetMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnAuthenticationOauthProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnAuthenticationOauthProviderParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAuthenticationOauthProvider",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/authenticationOauthProviders/{oauthProviderName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnAuthenticationOauthProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnAuthenticationOauthProviderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnAuthenticationOauthProviderDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnAuthenticationOauthProviders gets a list of o auth provider objects

  Get a list of OAuth Provider objects.

OAuth Providers contain information about the issuer of an OAuth token that is needed to validate the token and derive a client username from it.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
oauthProviderName|x|||
tokenIntrospectionPassword||x||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.13.
*/
func (a *Client) GetMsgVpnAuthenticationOauthProviders(params *GetMsgVpnAuthenticationOauthProvidersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnAuthenticationOauthProvidersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnAuthenticationOauthProvidersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAuthenticationOauthProviders",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/authenticationOauthProviders",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnAuthenticationOauthProvidersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnAuthenticationOauthProvidersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnAuthenticationOauthProvidersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnAuthorizationGroup gets an l d a p authorization group object

  Get an LDAP Authorization Group object.

To use client authorization groups configured on an external LDAP server to provide client authorizations, LDAP Authorization Group objects must be created on the Message VPN that match the authorization groups provisioned on the LDAP server. These objects must be configured with the client profiles and ACL profiles that will be assigned to the clients that belong to those authorization groups. A newly created group is placed at the end of the group list which is the lowest priority.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
authorizationGroupName|x|||
msgVpnName|x|||
orderAfterAuthorizationGroupName||x||
orderBeforeAuthorizationGroupName||x||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnAuthorizationGroup(params *GetMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnAuthorizationGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnAuthorizationGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAuthorizationGroup",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/authorizationGroups/{authorizationGroupName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnAuthorizationGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnAuthorizationGroupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnAuthorizationGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnAuthorizationGroups gets a list of l d a p authorization group objects

  Get a list of LDAP Authorization Group objects.

To use client authorization groups configured on an external LDAP server to provide client authorizations, LDAP Authorization Group objects must be created on the Message VPN that match the authorization groups provisioned on the LDAP server. These objects must be configured with the client profiles and ACL profiles that will be assigned to the clients that belong to those authorization groups. A newly created group is placed at the end of the group list which is the lowest priority.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
authorizationGroupName|x|||
msgVpnName|x|||
orderAfterAuthorizationGroupName||x||
orderBeforeAuthorizationGroupName||x||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnAuthorizationGroups(params *GetMsgVpnAuthorizationGroupsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnAuthorizationGroupsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnAuthorizationGroupsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnAuthorizationGroups",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/authorizationGroups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnAuthorizationGroupsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnAuthorizationGroupsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnAuthorizationGroupsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnBridge gets a bridge object

  Get a Bridge object.

Bridges can be used to link two Message VPNs so that messages published to one Message VPN that match the topic subscriptions set for the bridge are also delivered to the linked Message VPN.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgeName|x|||
bridgeVirtualRouter|x|||
msgVpnName|x|||
remoteAuthenticationBasicPassword||x||x
remoteAuthenticationClientCertContent||x||x
remoteAuthenticationClientCertPassword||x||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnBridge(params *GetMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnBridge",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnBridgeRemoteMsgVpn gets a remote message v p n object

  Get a Remote Message VPN object.

The Remote Message VPN is the Message VPN that the Bridge connects to.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgeName|x|||
bridgeVirtualRouter|x|||
msgVpnName|x|||
password||x||x
remoteMsgVpnInterface|x|||
remoteMsgVpnLocation|x|||
remoteMsgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnBridgeRemoteMsgVpn(params *GetMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeRemoteMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnBridgeRemoteMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnBridgeRemoteMsgVpn",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteMsgVpns/{remoteMsgVpnName},{remoteMsgVpnLocation},{remoteMsgVpnInterface}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnBridgeRemoteMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnBridgeRemoteMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnBridgeRemoteMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnBridgeRemoteMsgVpns gets a list of remote message v p n objects

  Get a list of Remote Message VPN objects.

The Remote Message VPN is the Message VPN that the Bridge connects to.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgeName|x|||
bridgeVirtualRouter|x|||
msgVpnName|x|||
password||x||x
remoteMsgVpnInterface|x|||
remoteMsgVpnLocation|x|||
remoteMsgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnBridgeRemoteMsgVpns(params *GetMsgVpnBridgeRemoteMsgVpnsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeRemoteMsgVpnsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnBridgeRemoteMsgVpnsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnBridgeRemoteMsgVpns",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteMsgVpns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnBridgeRemoteMsgVpnsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnBridgeRemoteMsgVpnsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnBridgeRemoteMsgVpnsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnBridgeRemoteSubscription gets a remote subscription object

  Get a Remote Subscription object.

A Remote Subscription is a topic subscription used by the Message VPN Bridge to attract messages from the remote message broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgeName|x|||
bridgeVirtualRouter|x|||
msgVpnName|x|||
remoteSubscriptionTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnBridgeRemoteSubscription(params *GetMsgVpnBridgeRemoteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeRemoteSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnBridgeRemoteSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnBridgeRemoteSubscription",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteSubscriptions/{remoteSubscriptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnBridgeRemoteSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnBridgeRemoteSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnBridgeRemoteSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnBridgeRemoteSubscriptions gets a list of remote subscription objects

  Get a list of Remote Subscription objects.

A Remote Subscription is a topic subscription used by the Message VPN Bridge to attract messages from the remote message broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgeName|x|||
bridgeVirtualRouter|x|||
msgVpnName|x|||
remoteSubscriptionTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnBridgeRemoteSubscriptions(params *GetMsgVpnBridgeRemoteSubscriptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeRemoteSubscriptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnBridgeRemoteSubscriptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnBridgeRemoteSubscriptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteSubscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnBridgeRemoteSubscriptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnBridgeRemoteSubscriptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnBridgeRemoteSubscriptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnBridgeTLSTrustedCommonName gets a trusted common name object

  Get a Trusted Common Name object.

The Trusted Common Names for the Bridge are used by encrypted transports to verify the name in the certificate presented by the remote node. They must include the common name of the remote node's server certificate or client certificate, depending upon the initiator of the connection.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgeName|x||x|
bridgeVirtualRouter|x||x|
msgVpnName|x||x|
tlsTrustedCommonName|x||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been deprecated since 2.18. Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) GetMsgVpnBridgeTLSTrustedCommonName(params *GetMsgVpnBridgeTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnBridgeTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnBridgeTlsTrustedCommonName",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/tlsTrustedCommonNames/{tlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnBridgeTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnBridgeTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnBridgeTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnBridgeTLSTrustedCommonNames gets a list of trusted common name objects

  Get a list of Trusted Common Name objects.

The Trusted Common Names for the Bridge are used by encrypted transports to verify the name in the certificate presented by the remote node. They must include the common name of the remote node's server certificate or client certificate, depending upon the initiator of the connection.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgeName|x||x|
bridgeVirtualRouter|x||x|
msgVpnName|x||x|
tlsTrustedCommonName|x||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been deprecated since 2.18. Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) GetMsgVpnBridgeTLSTrustedCommonNames(params *GetMsgVpnBridgeTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgeTLSTrustedCommonNamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnBridgeTLSTrustedCommonNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnBridgeTlsTrustedCommonNames",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/tlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnBridgeTLSTrustedCommonNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnBridgeTLSTrustedCommonNamesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnBridgeTLSTrustedCommonNamesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnBridges gets a list of bridge objects

  Get a list of Bridge objects.

Bridges can be used to link two Message VPNs so that messages published to one Message VPN that match the topic subscriptions set for the bridge are also delivered to the linked Message VPN.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgeName|x|||
bridgeVirtualRouter|x|||
msgVpnName|x|||
remoteAuthenticationBasicPassword||x||x
remoteAuthenticationClientCertContent||x||x
remoteAuthenticationClientCertPassword||x||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnBridges(params *GetMsgVpnBridgesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnBridgesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnBridgesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnBridges",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnBridgesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnBridgesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnBridgesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnClientProfile gets a client profile object

  Get a Client Profile object.

Client Profiles are used to assign common configuration properties to clients that have been successfully authorized.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
apiQueueManagementCopyFromOnCreateName|||x|
apiTopicEndpointManagementCopyFromOnCreateName|||x|
clientProfileName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnClientProfile(params *GetMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnClientProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnClientProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnClientProfile",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/clientProfiles/{clientProfileName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnClientProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnClientProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnClientProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnClientProfiles gets a list of client profile objects

  Get a list of Client Profile objects.

Client Profiles are used to assign common configuration properties to clients that have been successfully authorized.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
apiQueueManagementCopyFromOnCreateName|||x|
apiTopicEndpointManagementCopyFromOnCreateName|||x|
clientProfileName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnClientProfiles(params *GetMsgVpnClientProfilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnClientProfilesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnClientProfilesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnClientProfiles",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/clientProfiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnClientProfilesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnClientProfilesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnClientProfilesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnClientUsername gets a client username object

  Get a Client Username object.

A client is only authorized to connect to a Message VPN that is associated with a Client Username that the client has been assigned.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
clientUsername|x|||
msgVpnName|x|||
password||x||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnClientUsername(params *GetMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnClientUsernameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnClientUsernameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnClientUsername",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/clientUsernames/{clientUsername}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnClientUsernameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnClientUsernameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnClientUsernameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnClientUsernames gets a list of client username objects

  Get a list of Client Username objects.

A client is only authorized to connect to a Message VPN that is associated with a Client Username that the client has been assigned.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
clientUsername|x|||
msgVpnName|x|||
password||x||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnClientUsernames(params *GetMsgVpnClientUsernamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnClientUsernamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnClientUsernamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnClientUsernames",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/clientUsernames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnClientUsernamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnClientUsernamesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnClientUsernamesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCache gets a distributed cache object

  Get a Distributed Cache object.

A Distributed Cache is a collection of one or more Cache Clusters that belong to the same Message VPN. Each Cache Cluster in a Distributed Cache is configured to subscribe to a different set of topics. This effectively divides up the configured topic space, to provide scaling to very large topic spaces or very high cached message throughput.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCache(params *GetMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCache",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheCluster gets a cache cluster object

  Get a Cache Cluster object.

A Cache Cluster is a collection of one or more Cache Instances that subscribe to exactly the same topics. Cache Instances are grouped together in a Cache Cluster for the purpose of fault tolerance and load balancing. As published messages are received, the message broker message bus sends these live data messages to the Cache Instances in the Cache Cluster. This enables client cache requests to be served by any of Cache Instances in the Cache Cluster.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheCluster(params *GetMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheCluster",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusterGlobalCachingHomeCluster gets a home cache cluster object

  Get a Home Cache Cluster object.

A Home Cache Cluster is a Cache Cluster that is the "definitive" Cache Cluster for a given topic in the context of the Global Caching feature.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
homeClusterName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusterGlobalCachingHomeCluster(params *GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusterGlobalCachingHomeCluster",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/globalCachingHomeClusters/{homeClusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix gets a topic prefix object

  Get a Topic Prefix object.

A Topic Prefix is a prefix for a global topic that is available from the containing Home Cache Cluster.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
homeClusterName|x|||
msgVpnName|x|||
topicPrefix|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix(params *GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefix",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/globalCachingHomeClusters/{homeClusterName}/topicPrefixes/{topicPrefix}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixes gets a list of topic prefix objects

  Get a list of Topic Prefix objects.

A Topic Prefix is a prefix for a global topic that is available from the containing Home Cache Cluster.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
homeClusterName|x|||
msgVpnName|x|||
topicPrefix|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixes(params *GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixes",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/globalCachingHomeClusters/{homeClusterName}/topicPrefixes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusterTopicPrefixesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusters gets a list of home cache cluster objects

  Get a list of Home Cache Cluster objects.

A Home Cache Cluster is a Cache Cluster that is the "definitive" Cache Cluster for a given topic in the context of the Global Caching feature.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
homeClusterName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusterGlobalCachingHomeClusters(params *GetMsgVpnDistributedCacheClusterGlobalCachingHomeClustersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClustersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterGlobalCachingHomeClustersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusterGlobalCachingHomeClusters",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/globalCachingHomeClusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterGlobalCachingHomeClustersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClustersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterGlobalCachingHomeClustersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusterInstance gets a cache instance object

  Get a Cache Instance object.

A Cache Instance is a single Cache process that belongs to a single Cache Cluster. A Cache Instance object provisioned on the broker is used to disseminate configuration information to the Cache process. Cache Instances listen for and cache live data messages that match the topic subscriptions configured for their parent Cache Cluster.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
instanceName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusterInstance(params *GetMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterInstanceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterInstanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusterInstance",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/instances/{instanceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterInstanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterInstanceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterInstanceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusterInstances gets a list of cache instance objects

  Get a list of Cache Instance objects.

A Cache Instance is a single Cache process that belongs to a single Cache Cluster. A Cache Instance object provisioned on the broker is used to disseminate configuration information to the Cache process. Cache Instances listen for and cache live data messages that match the topic subscriptions configured for their parent Cache Cluster.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
instanceName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusterInstances(params *GetMsgVpnDistributedCacheClusterInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterInstancesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterInstancesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusterInstances",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterInstancesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterInstancesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterInstancesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusterTopic gets a topic object

  Get a Topic object.

The Cache Instances that belong to the containing Cache Cluster will cache any messages published to topics that match a Topic Subscription.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
msgVpnName|x|||
topic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusterTopic(params *GetMsgVpnDistributedCacheClusterTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusterTopic",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/topics/{topic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusterTopics gets a list of topic objects

  Get a list of Topic objects.

The Cache Instances that belong to the containing Cache Cluster will cache any messages published to topics that match a Topic Subscription.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
msgVpnName|x|||
topic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusterTopics(params *GetMsgVpnDistributedCacheClusterTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClusterTopicsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClusterTopicsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusterTopics",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/topics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClusterTopicsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClusterTopicsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClusterTopicsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCacheClusters gets a list of cache cluster objects

  Get a list of Cache Cluster objects.

A Cache Cluster is a collection of one or more Cache Instances that subscribe to exactly the same topics. Cache Instances are grouped together in a Cache Cluster for the purpose of fault tolerance and load balancing. As published messages are received, the message broker message bus sends these live data messages to the Cache Instances in the Cache Cluster. This enables client cache requests to be served by any of Cache Instances in the Cache Cluster.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
clusterName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCacheClusters(params *GetMsgVpnDistributedCacheClustersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCacheClustersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCacheClustersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCacheClusters",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCacheClustersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCacheClustersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCacheClustersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDistributedCaches gets a list of distributed cache objects

  Get a list of Distributed Cache objects.

A Distributed Cache is a collection of one or more Cache Clusters that belong to the same Message VPN. Each Cache Cluster in a Distributed Cache is configured to subscribe to a different set of topics. This effectively divides up the configured topic space, to provide scaling to very large topic spaces or very high cached message throughput.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDistributedCaches(params *GetMsgVpnDistributedCachesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDistributedCachesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDistributedCachesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDistributedCaches",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDistributedCachesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDistributedCachesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDistributedCachesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDmrBridge gets a d m r bridge object

  Get a DMR Bridge object.

A DMR Bridge is required to establish a data channel over a corresponding external link to the remote node for a given Message VPN. Each DMR Bridge identifies which external link the Message VPN should use, and what the name of the equivalent Message VPN at the remote node is.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
remoteNodeName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDmrBridge(params *GetMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDmrBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDmrBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDmrBridge",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/dmrBridges/{remoteNodeName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDmrBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDmrBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDmrBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnDmrBridges gets a list of d m r bridge objects

  Get a list of DMR Bridge objects.

A DMR Bridge is required to establish a data channel over a corresponding external link to the remote node for a given Message VPN. Each DMR Bridge identifies which external link the Message VPN should use, and what the name of the equivalent Message VPN at the remote node is.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
remoteNodeName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnDmrBridges(params *GetMsgVpnDmrBridgesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnDmrBridgesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnDmrBridgesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnDmrBridges",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/dmrBridges",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnDmrBridgesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnDmrBridgesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnDmrBridgesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnJndiConnectionFactories gets a list of j n d i connection factory objects

  Get a list of JNDI Connection Factory objects.

The message broker provides an internal JNDI store for provisioned Connection Factory objects that clients can access through JNDI lookups.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
connectionFactoryName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetMsgVpnJndiConnectionFactories(params *GetMsgVpnJndiConnectionFactoriesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiConnectionFactoriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnJndiConnectionFactoriesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnJndiConnectionFactories",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiConnectionFactories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnJndiConnectionFactoriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnJndiConnectionFactoriesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnJndiConnectionFactoriesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnJndiConnectionFactory gets a j n d i connection factory object

  Get a JNDI Connection Factory object.

The message broker provides an internal JNDI store for provisioned Connection Factory objects that clients can access through JNDI lookups.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
connectionFactoryName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetMsgVpnJndiConnectionFactory(params *GetMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiConnectionFactoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnJndiConnectionFactoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnJndiConnectionFactory",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiConnectionFactories/{connectionFactoryName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnJndiConnectionFactoryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnJndiConnectionFactoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnJndiConnectionFactoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnJndiQueue gets a j n d i queue object

  Get a JNDI Queue object.

The message broker provides an internal JNDI store for provisioned Queue objects that clients can access through JNDI lookups.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetMsgVpnJndiQueue(params *GetMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnJndiQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnJndiQueue",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiQueues/{queueName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnJndiQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnJndiQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnJndiQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnJndiQueues gets a list of j n d i queue objects

  Get a list of JNDI Queue objects.

The message broker provides an internal JNDI store for provisioned Queue objects that clients can access through JNDI lookups.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetMsgVpnJndiQueues(params *GetMsgVpnJndiQueuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiQueuesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnJndiQueuesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnJndiQueues",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiQueues",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnJndiQueuesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnJndiQueuesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnJndiQueuesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnJndiTopic gets a j n d i topic object

  Get a JNDI Topic object.

The message broker provides an internal JNDI store for provisioned Topic objects that clients can access through JNDI lookups.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
topicName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetMsgVpnJndiTopic(params *GetMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnJndiTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnJndiTopic",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiTopics/{topicName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnJndiTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnJndiTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnJndiTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnJndiTopics gets a list of j n d i topic objects

  Get a list of JNDI Topic objects.

The message broker provides an internal JNDI store for provisioned Topic objects that clients can access through JNDI lookups.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
topicName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) GetMsgVpnJndiTopics(params *GetMsgVpnJndiTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnJndiTopicsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnJndiTopicsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnJndiTopics",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiTopics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnJndiTopicsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnJndiTopicsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnJndiTopicsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnMqttRetainCache gets an m q t t retain cache object

  Get an MQTT Retain Cache object.

Using MQTT retained messages allows publishing MQTT clients to indicate that a message must be stored for later delivery to subscribing clients when those subscribing clients add subscriptions matching the retained message's topic. An MQTT Retain Cache processes all retained messages for a Message VPN.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnMqttRetainCache(params *GetMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttRetainCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnMqttRetainCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnMqttRetainCache",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttRetainCaches/{cacheName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnMqttRetainCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnMqttRetainCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnMqttRetainCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnMqttRetainCaches gets a list of m q t t retain cache objects

  Get a list of MQTT Retain Cache objects.

Using MQTT retained messages allows publishing MQTT clients to indicate that a message must be stored for later delivery to subscribing clients when those subscribing clients add subscriptions matching the retained message's topic. An MQTT Retain Cache processes all retained messages for a Message VPN.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
cacheName|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) GetMsgVpnMqttRetainCaches(params *GetMsgVpnMqttRetainCachesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttRetainCachesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnMqttRetainCachesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnMqttRetainCaches",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttRetainCaches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnMqttRetainCachesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnMqttRetainCachesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnMqttRetainCachesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnMqttSession gets an m q t t session object

  Get an MQTT Session object.

An MQTT Session object is a virtual representation of an MQTT client connection. An MQTT session holds the state of an MQTT client (that is, it is used to contain a client's QoS 0 and QoS 1 subscription sets and any undelivered QoS 1 messages).


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
mqttSessionClientId|x|||
mqttSessionVirtualRouter|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) GetMsgVpnMqttSession(params *GetMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnMqttSessionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnMqttSession",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnMqttSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnMqttSessionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnMqttSessionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnMqttSessionSubscription gets a subscription object

  Get a Subscription object.

An MQTT session contains a client's QoS 0 and QoS 1 subscription sets. On creation, a subscription defaults to QoS 0.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
mqttSessionClientId|x|||
mqttSessionVirtualRouter|x|||
msgVpnName|x|||
subscriptionTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) GetMsgVpnMqttSessionSubscription(params *GetMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttSessionSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnMqttSessionSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnMqttSessionSubscription",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}/subscriptions/{subscriptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnMqttSessionSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnMqttSessionSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnMqttSessionSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnMqttSessionSubscriptions gets a list of subscription objects

  Get a list of Subscription objects.

An MQTT session contains a client's QoS 0 and QoS 1 subscription sets. On creation, a subscription defaults to QoS 0.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
mqttSessionClientId|x|||
mqttSessionVirtualRouter|x|||
msgVpnName|x|||
subscriptionTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) GetMsgVpnMqttSessionSubscriptions(params *GetMsgVpnMqttSessionSubscriptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttSessionSubscriptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnMqttSessionSubscriptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnMqttSessionSubscriptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}/subscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnMqttSessionSubscriptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnMqttSessionSubscriptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnMqttSessionSubscriptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnMqttSessions gets a list of m q t t session objects

  Get a list of MQTT Session objects.

An MQTT Session object is a virtual representation of an MQTT client connection. An MQTT session holds the state of an MQTT client (that is, it is used to contain a client's QoS 0 and QoS 1 subscription sets and any undelivered QoS 1 messages).


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
mqttSessionClientId|x|||
mqttSessionVirtualRouter|x|||
msgVpnName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) GetMsgVpnMqttSessions(params *GetMsgVpnMqttSessionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnMqttSessionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnMqttSessionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnMqttSessions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnMqttSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnMqttSessionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnMqttSessionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnQueue gets a queue object

  Get a Queue object.

A Queue acts as both a destination that clients can publish messages to, and as an endpoint that clients can bind consumers to and consume messages from.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnQueue(params *GetMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnQueue",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/queues/{queueName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnQueueSubscription gets a queue subscription object

  Get a Queue Subscription object.

One or more Queue Subscriptions can be added to a durable queue so that Guaranteed messages published to matching topics are also delivered to and spooled by the queue.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueName|x|||
subscriptionTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnQueueSubscription(params *GetMsgVpnQueueSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnQueueSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnQueueSubscription",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/queues/{queueName}/subscriptions/{subscriptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnQueueSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnQueueSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnQueueSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnQueueSubscriptions gets a list of queue subscription objects

  Get a list of Queue Subscription objects.

One or more Queue Subscriptions can be added to a durable queue so that Guaranteed messages published to matching topics are also delivered to and spooled by the queue.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueName|x|||
subscriptionTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnQueueSubscriptions(params *GetMsgVpnQueueSubscriptionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueSubscriptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnQueueSubscriptionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnQueueSubscriptions",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/queues/{queueName}/subscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnQueueSubscriptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnQueueSubscriptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnQueueSubscriptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnQueueTemplate gets a queue template object

  Get a Queue Template object.

A Queue Template provides a mechanism for specifying the initial state for client created queues.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueTemplateName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnQueueTemplate(params *GetMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnQueueTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnQueueTemplate",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/queueTemplates/{queueTemplateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnQueueTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnQueueTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnQueueTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnQueueTemplates gets a list of queue template objects

  Get a list of Queue Template objects.

A Queue Template provides a mechanism for specifying the initial state for client created queues.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueTemplateName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnQueueTemplates(params *GetMsgVpnQueueTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueueTemplatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnQueueTemplatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnQueueTemplates",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/queueTemplates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnQueueTemplatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnQueueTemplatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnQueueTemplatesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnQueues gets a list of queue objects

  Get a list of Queue objects.

A Queue acts as both a destination that clients can publish messages to, and as an endpoint that clients can bind consumers to and consume messages from.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnQueues(params *GetMsgVpnQueuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnQueuesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnQueuesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnQueues",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/queues",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnQueuesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnQueuesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnQueuesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnReplayLog gets a replay log object

  Get a Replay Log object.

When the Message Replay feature is enabled, message brokers store persistent messages in a Replay Log. These messages are kept until the log is full, after which the oldest messages are removed to free up space for new messages.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
replayLogName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.10.
*/
func (a *Client) GetMsgVpnReplayLog(params *GetMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnReplayLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnReplayLogParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnReplayLog",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/replayLogs/{replayLogName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnReplayLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnReplayLogOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnReplayLogDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnReplayLogs gets a list of replay log objects

  Get a list of Replay Log objects.

When the Message Replay feature is enabled, message brokers store persistent messages in a Replay Log. These messages are kept until the log is full, after which the oldest messages are removed to free up space for new messages.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
replayLogName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.10.
*/
func (a *Client) GetMsgVpnReplayLogs(params *GetMsgVpnReplayLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnReplayLogsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnReplayLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnReplayLogs",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/replayLogs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnReplayLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnReplayLogsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnReplayLogsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnReplicatedTopic gets a replicated topic object

  Get a Replicated Topic object.

To indicate which messages should be replicated between the active and standby site, a Replicated Topic subscription must be configured on a Message VPN. If a published message matches both a replicated topic and an endpoint on the active site, then the message is replicated to the standby site.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
replicatedTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) GetMsgVpnReplicatedTopic(params *GetMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnReplicatedTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnReplicatedTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnReplicatedTopic",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/replicatedTopics/{replicatedTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnReplicatedTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnReplicatedTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnReplicatedTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnReplicatedTopics gets a list of replicated topic objects

  Get a list of Replicated Topic objects.

To indicate which messages should be replicated between the active and standby site, a Replicated Topic subscription must be configured on a Message VPN. If a published message matches both a replicated topic and an endpoint on the active site, then the message is replicated to the standby site.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
replicatedTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) GetMsgVpnReplicatedTopics(params *GetMsgVpnReplicatedTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnReplicatedTopicsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnReplicatedTopicsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnReplicatedTopics",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/replicatedTopics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnReplicatedTopicsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnReplicatedTopicsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnReplicatedTopicsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPoint gets a r e s t delivery point object

  Get a REST Delivery Point object.

A REST Delivery Point manages delivery of messages from queues to a named list of REST Consumers.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
restDeliveryPointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnRestDeliveryPoint(params *GetMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPoint",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPointQueueBinding gets a queue binding object

  Get a Queue Binding object.

A Queue Binding for a REST Delivery Point attracts messages to be delivered to REST consumers. If the queue does not exist it can be created subsequently, and once the queue is operational the broker performs the queue binding. Removing the queue binding does not delete the queue itself. Similarly, removing the queue does not remove the queue binding, which fails until the queue is recreated or the queue binding is deleted.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueBindingName|x|||
restDeliveryPointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnRestDeliveryPointQueueBinding(params *GetMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointQueueBindingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointQueueBindingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPointQueueBinding",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/queueBindings/{queueBindingName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointQueueBindingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointQueueBindingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointQueueBindingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPointQueueBindings gets a list of queue binding objects

  Get a list of Queue Binding objects.

A Queue Binding for a REST Delivery Point attracts messages to be delivered to REST consumers. If the queue does not exist it can be created subsequently, and once the queue is operational the broker performs the queue binding. Removing the queue binding does not delete the queue itself. Similarly, removing the queue does not remove the queue binding, which fails until the queue is recreated or the queue binding is deleted.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
queueBindingName|x|||
restDeliveryPointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnRestDeliveryPointQueueBindings(params *GetMsgVpnRestDeliveryPointQueueBindingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointQueueBindingsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointQueueBindingsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPointQueueBindings",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/queueBindings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointQueueBindingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointQueueBindingsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointQueueBindingsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPointRestConsumer gets a r e s t consumer object

  Get a REST Consumer object.

REST Consumer objects establish HTTP connectivity to REST consumer applications who wish to receive messages from a broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
authenticationClientCertContent||x||x
authenticationClientCertPassword||x||
authenticationHttpBasicPassword||x||x
authenticationHttpHeaderValue||x||x
authenticationOauthClientSecret||x||x
authenticationOauthJwtSecretKey||x||x
msgVpnName|x|||
restConsumerName|x|||
restDeliveryPointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnRestDeliveryPointRestConsumer(params *GetMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointRestConsumerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPointRestConsumer",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointRestConsumerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointRestConsumerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointRestConsumerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim gets a claim object

  Get a Claim object.

A Claim is added to the JWT sent to the OAuth token request endpoint.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
oauthJwtClaimName|x|||
restConsumerName|x|||
restDeliveryPointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.21.
*/
func (a *Client) GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim(params *GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPointRestConsumerOauthJwtClaim",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}/oauthJwtClaims/{oauthJwtClaimName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaims gets a list of claim objects

  Get a list of Claim objects.

A Claim is added to the JWT sent to the OAuth token request endpoint.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
oauthJwtClaimName|x|||
restConsumerName|x|||
restDeliveryPointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.21.
*/
func (a *Client) GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaims(params *GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPointRestConsumerOauthJwtClaims",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}/oauthJwtClaims",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointRestConsumerOauthJwtClaimsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName gets a trusted common name object

  Get a Trusted Common Name object.

The Trusted Common Names for the REST Consumer are used by encrypted transports to verify the name in the certificate presented by the remote REST consumer. They must include the common name of the remote REST consumer's server certificate.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x||x|
restConsumerName|x||x|
restDeliveryPointName|x||x|
tlsTrustedCommonName|x||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been deprecated since (will be deprecated in next SEMP version). Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonName(params *GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPointRestConsumerTlsTrustedCommonName",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}/tlsTrustedCommonNames/{tlsTrustedCommonName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNames gets a list of trusted common name objects

  Get a list of Trusted Common Name objects.

The Trusted Common Names for the REST Consumer are used by encrypted transports to verify the name in the certificate presented by the remote REST consumer. They must include the common name of the remote REST consumer's server certificate.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x||x|
restConsumerName|x||x|
restDeliveryPointName|x||x|
tlsTrustedCommonName|x||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been deprecated since (will be deprecated in next SEMP version). Common Name validation has been replaced by Server Certificate Name validation.
*/
func (a *Client) GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNames(params *GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPointRestConsumerTlsTrustedCommonNames",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}/tlsTrustedCommonNames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNamesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointRestConsumerTLSTrustedCommonNamesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPointRestConsumers gets a list of r e s t consumer objects

  Get a list of REST Consumer objects.

REST Consumer objects establish HTTP connectivity to REST consumer applications who wish to receive messages from a broker.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
authenticationClientCertContent||x||x
authenticationClientCertPassword||x||
authenticationHttpBasicPassword||x||x
authenticationHttpHeaderValue||x||x
authenticationOauthClientSecret||x||x
authenticationOauthJwtSecretKey||x||x
msgVpnName|x|||
restConsumerName|x|||
restDeliveryPointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnRestDeliveryPointRestConsumers(params *GetMsgVpnRestDeliveryPointRestConsumersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointRestConsumersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointRestConsumersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPointRestConsumers",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointRestConsumersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointRestConsumersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointRestConsumersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnRestDeliveryPoints gets a list of r e s t delivery point objects

  Get a list of REST Delivery Point objects.

A REST Delivery Point manages delivery of messages from queues to a named list of REST Consumers.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
restDeliveryPointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnRestDeliveryPoints(params *GetMsgVpnRestDeliveryPointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnRestDeliveryPointsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnRestDeliveryPointsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnRestDeliveryPoints",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnRestDeliveryPointsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnRestDeliveryPointsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnRestDeliveryPointsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnSequencedTopic gets a sequenced topic object

  Get a Sequenced Topic object.

A Sequenced Topic is a topic subscription for which any matching messages received on the Message VPN are assigned a sequence number that is monotonically increased by a value of one per message.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
sequencedTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnSequencedTopic(params *GetMsgVpnSequencedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnSequencedTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnSequencedTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnSequencedTopic",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/sequencedTopics/{sequencedTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnSequencedTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnSequencedTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnSequencedTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnSequencedTopics gets a list of sequenced topic objects

  Get a list of Sequenced Topic objects.

A Sequenced Topic is a topic subscription for which any matching messages received on the Message VPN are assigned a sequence number that is monotonically increased by a value of one per message.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
sequencedTopic|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpnSequencedTopics(params *GetMsgVpnSequencedTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnSequencedTopicsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnSequencedTopicsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnSequencedTopics",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/sequencedTopics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnSequencedTopicsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnSequencedTopicsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnSequencedTopicsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnTopicEndpoint gets a topic endpoint object

  Get a Topic Endpoint object.

A Topic Endpoint attracts messages published to a topic for which the Topic Endpoint has a matching topic subscription. The topic subscription for the Topic Endpoint is specified in the client request to bind a Flow to that Topic Endpoint. Queues are significantly more flexible than Topic Endpoints and are the recommended approach for most applications. The use of Topic Endpoints should be restricted to JMS applications.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
topicEndpointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) GetMsgVpnTopicEndpoint(params *GetMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnTopicEndpointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnTopicEndpointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnTopicEndpoint",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpoints/{topicEndpointName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnTopicEndpointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnTopicEndpointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnTopicEndpointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnTopicEndpointTemplate gets a topic endpoint template object

  Get a Topic Endpoint Template object.

A Topic Endpoint Template provides a mechanism for specifying the initial state for client created topic endpoints.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
topicEndpointTemplateName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnTopicEndpointTemplate(params *GetMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnTopicEndpointTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnTopicEndpointTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnTopicEndpointTemplate",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpointTemplates/{topicEndpointTemplateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnTopicEndpointTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnTopicEndpointTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnTopicEndpointTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnTopicEndpointTemplates gets a list of topic endpoint template objects

  Get a list of Topic Endpoint Template objects.

A Topic Endpoint Template provides a mechanism for specifying the initial state for client created topic endpoints.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
topicEndpointTemplateName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) GetMsgVpnTopicEndpointTemplates(params *GetMsgVpnTopicEndpointTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnTopicEndpointTemplatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnTopicEndpointTemplatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnTopicEndpointTemplates",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpointTemplates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnTopicEndpointTemplatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnTopicEndpointTemplatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnTopicEndpointTemplatesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpnTopicEndpoints gets a list of topic endpoint objects

  Get a list of Topic Endpoint objects.

A Topic Endpoint attracts messages published to a topic for which the Topic Endpoint has a matching topic subscription. The topic subscription for the Topic Endpoint is specified in the client request to bind a Flow to that Topic Endpoint. Queues are significantly more flexible than Topic Endpoints and are the recommended approach for most applications. The use of Topic Endpoints should be restricted to JMS applications.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
msgVpnName|x|||
topicEndpointName|x|||



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) GetMsgVpnTopicEndpoints(params *GetMsgVpnTopicEndpointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnTopicEndpointsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnTopicEndpointsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpnTopicEndpoints",
		Method:             "GET",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpoints",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnTopicEndpointsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnTopicEndpointsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnTopicEndpointsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMsgVpns gets a list of message v p n objects

  Get a list of Message VPN objects.

Message VPNs (Virtual Private Networks) allow for the segregation of topic space and clients. They also group clients connecting to a network of message brokers, such that messages published within a particular group are only visible to that group's clients.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
bridgingTlsServerCertEnforceTrustedCommonNameEnabled|||x|
msgVpnName|x|||
replicationBridgeAuthenticationBasicPassword||x||x
replicationBridgeAuthenticationClientCertContent||x||x
replicationBridgeAuthenticationClientCertPassword||x||
replicationEnabledQueueBehavior||x||
restTlsServerCertEnforceTrustedCommonNameEnabled|||x|



A SEMP client authorized with a minimum access scope/level of "vpn/read-only" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) GetMsgVpns(params *GetMsgVpnsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMsgVpnsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMsgVpnsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMsgVpns",
		Method:             "GET",
		PathPattern:        "/msgVpns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMsgVpnsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMsgVpnsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMsgVpnsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetSystemInformation gets a system information object

  Get a System Information object.

The System Information object provides metadata about the SEMP API.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
platform|||x|
sempVersion|||x|



A SEMP client authorized with a minimum access scope/level of "global/none" is required to perform this operation.

This has been deprecated since 2.2. /systemInformation was replaced by /about/api.
*/
func (a *Client) GetSystemInformation(params *GetSystemInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSystemInformationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSystemInformationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getSystemInformation",
		Method:             "GET",
		PathPattern:        "/systemInformation",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSystemInformationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSystemInformationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSystemInformationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetVirtualHostname gets a virtual hostname object

  Get a Virtual Hostname object.

A Virtual Hostname is a provisioned object on a message broker that contains a Virtual Hostname to Message VPN mapping.

Clients which connect to a global (as opposed to per Message VPN) port and provides this hostname will be directed to its corresponding Message VPN. A case-insentive match is performed on the full client-provided hostname against the configured virtual-hostname.

This mechanism is only supported for hostnames provided through the Server Name Indication (SNI) extension of TLS.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
virtualHostname|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.17.
*/
func (a *Client) GetVirtualHostname(params *GetVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetVirtualHostnameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetVirtualHostnameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getVirtualHostname",
		Method:             "GET",
		PathPattern:        "/virtualHostnames/{virtualHostname}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetVirtualHostnameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetVirtualHostnameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetVirtualHostnameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetVirtualHostnames gets a list of virtual hostname objects

  Get a list of Virtual Hostname objects.

A Virtual Hostname is a provisioned object on a message broker that contains a Virtual Hostname to Message VPN mapping.

Clients which connect to a global (as opposed to per Message VPN) port and provides this hostname will be directed to its corresponding Message VPN. A case-insentive match is performed on the full client-provided hostname against the configured virtual-hostname.

This mechanism is only supported for hostnames provided through the Server Name Indication (SNI) extension of TLS.


Attribute|Identifying|Write-Only|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:
virtualHostname|x|||



A SEMP client authorized with a minimum access scope/level of "global/read-only" is required to perform this operation.

This has been available since 2.17.
*/
func (a *Client) GetVirtualHostnames(params *GetVirtualHostnamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetVirtualHostnamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetVirtualHostnamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getVirtualHostnames",
		Method:             "GET",
		PathPattern:        "/virtualHostnames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetVirtualHostnamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetVirtualHostnamesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetVirtualHostnamesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceCertAuthority replaces a certificate authority object

  Replace a Certificate Authority object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x|||x|
certContent|||||x|
crlDayList|||||x|
crlTimeList|||||x|
crlUrl||||x|x|
ocspNonResponderCertEnabled|||||x|
ocspOverrideUrl|||||x|
ocspTimeout|||||x|
revocationCheckEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
CertAuthority|crlDayList|crlTimeList|
CertAuthority|crlTimeList|crlDayList|



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities and domainCertAuthorities.
*/
func (a *Client) ReplaceCertAuthority(params *ReplaceCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceCertAuthority",
		Method:             "PUT",
		PathPattern:        "/certAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceClientCertAuthority replaces a client certificate authority object

  Replace a Client Certificate Authority object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x||||
crlUrl||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
ClientCertAuthority|crlDayList|crlTimeList|
ClientCertAuthority|crlTimeList|crlDayList|



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) ReplaceClientCertAuthority(params *ReplaceClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceClientCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceClientCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceClientCertAuthority",
		Method:             "PUT",
		PathPattern:        "/clientCertAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceClientCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceClientCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceClientCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceDmrCluster replaces a cluster object

  Replace a Cluster object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Cluster is a provisioned object on a message broker that contains global DMR configuration parameters.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationBasicPassword|||x|x||x
authenticationClientCertContent|||x|x||x
authenticationClientCertPassword|||x|x||
directOnlyEnabled||x||||
dmrClusterName|x|x||||
nodeName||x||||
tlsServerCertEnforceTrustedCommonNameEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
DmrCluster|authenticationClientCertPassword|authenticationClientCertContent|



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) ReplaceDmrCluster(params *ReplaceDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceDmrClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceDmrClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceDmrCluster",
		Method:             "PUT",
		PathPattern:        "/dmrClusters/{dmrClusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceDmrClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceDmrClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceDmrClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceDmrClusterLink replaces a link object

  Replace a Link object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Link connects nodes (either within a Cluster or between two different Clusters) and allows them to exchange topology information, subscriptions and data.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationBasicPassword|||x|x||x
authenticationScheme||||x||
dmrClusterName|x|x||||
egressFlowWindowSize||||x||
initiator||||x||
remoteNodeName|x|x||||
span||||x||
transportCompressedEnabled||||x||
transportTlsEnabled||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) ReplaceDmrClusterLink(params *ReplaceDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceDmrClusterLinkOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceDmrClusterLinkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceDmrClusterLink",
		Method:             "PUT",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceDmrClusterLinkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceDmrClusterLinkOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceDmrClusterLinkDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceDomainCertAuthority replaces a domain certificate authority object

  Replace a Domain Certificate Authority object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

Certificate Authorities trusted for domain verification.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) ReplaceDomainCertAuthority(params *ReplaceDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceDomainCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceDomainCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceDomainCertAuthority",
		Method:             "PUT",
		PathPattern:        "/domainCertAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceDomainCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceDomainCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceDomainCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpn replaces a message v p n object

  Replace a Message VPN object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

Message VPNs (Virtual Private Networks) allow for the segregation of topic space and clients. They also group clients connecting to a network of message brokers, such that messages published within a particular group are only visible to that group's clients.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgingTlsServerCertEnforceTrustedCommonNameEnabled|||||x|
msgVpnName|x|x||||
replicationBridgeAuthenticationBasicPassword|||x|||x
replicationBridgeAuthenticationClientCertContent|||x|||x
replicationBridgeAuthenticationClientCertPassword|||x|||
replicationEnabledQueueBehavior|||x|||
restTlsServerCertEnforceTrustedCommonNameEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent
EventThresholdByValue|clearValue|setValue|
EventThresholdByValue|setValue|clearValue|
MsgVpn|authenticationBasicProfileName|authenticationBasicType|
MsgVpn|authorizationProfileName|authorizationType|
MsgVpn|eventPublishTopicFormatMqttEnabled|eventPublishTopicFormatSmfEnabled|
MsgVpn|eventPublishTopicFormatSmfEnabled|eventPublishTopicFormatMqttEnabled|
MsgVpn|replicationBridgeAuthenticationBasicClientUsername|replicationBridgeAuthenticationBasicPassword|
MsgVpn|replicationBridgeAuthenticationBasicPassword|replicationBridgeAuthenticationBasicClientUsername|
MsgVpn|replicationBridgeAuthenticationClientCertPassword|replicationBridgeAuthenticationClientCertContent|
MsgVpn|replicationEnabledQueueBehavior|replicationEnabled|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation. Requests which include the following attributes require greater access scope/level:


Attribute|Access Scope/Level
:---|:---:
alias|global/read-write
authenticationBasicEnabled|global/read-write
authenticationBasicProfileName|global/read-write
authenticationBasicRadiusDomain|global/read-write
authenticationBasicType|global/read-write
authenticationClientCertAllowApiProvidedUsernameEnabled|global/read-write
authenticationClientCertEnabled|global/read-write
authenticationClientCertMaxChainDepth|global/read-write
authenticationClientCertRevocationCheckMode|global/read-write
authenticationClientCertUsernameSource|global/read-write
authenticationClientCertValidateDateEnabled|global/read-write
authenticationKerberosAllowApiProvidedUsernameEnabled|global/read-write
authenticationKerberosEnabled|global/read-write
authenticationOauthEnabled|global/read-write
bridgingTlsServerCertEnforceTrustedCommonNameEnabled|global/read-write
bridgingTlsServerCertMaxChainDepth|global/read-write
bridgingTlsServerCertValidateDateEnabled|global/read-write
bridgingTlsServerCertValidateNameEnabled|global/read-write
dmrEnabled|global/read-write
exportSubscriptionsEnabled|global/read-write
maxConnectionCount|global/read-write
maxEgressFlowCount|global/read-write
maxEndpointCount|global/read-write
maxIngressFlowCount|global/read-write
maxMsgSpoolUsage|global/read-write
maxSubscriptionCount|global/read-write
maxTransactedSessionCount|global/read-write
maxTransactionCount|global/read-write
mqttRetainMaxMemory|global/read-write
replicationBridgeAuthenticationBasicClientUsername|global/read-write
replicationBridgeAuthenticationBasicPassword|global/read-write
replicationBridgeAuthenticationClientCertContent|global/read-write
replicationBridgeAuthenticationClientCertPassword|global/read-write
replicationBridgeAuthenticationScheme|global/read-write
replicationBridgeCompressedDataEnabled|global/read-write
replicationBridgeEgressFlowWindowSize|global/read-write
replicationBridgeRetryDelay|global/read-write
replicationBridgeTlsEnabled|global/read-write
replicationBridgeUnidirectionalClientProfileName|global/read-write
replicationEnabled|global/read-write
replicationEnabledQueueBehavior|global/read-write
replicationQueueMaxMsgSpoolUsage|global/read-write
replicationRole|global/read-write
restTlsServerCertEnforceTrustedCommonNameEnabled|global/read-write
restTlsServerCertMaxChainDepth|global/read-write
restTlsServerCertValidateDateEnabled|global/read-write
restTlsServerCertValidateNameEnabled|global/read-write
sempOverMsgBusAdminClientEnabled|global/read-write
sempOverMsgBusAdminDistributedCacheEnabled|global/read-write
sempOverMsgBusAdminEnabled|global/read-write
sempOverMsgBusEnabled|global/read-write
sempOverMsgBusShowEnabled|global/read-write
serviceAmqpMaxConnectionCount|global/read-write
serviceAmqpPlainTextListenPort|global/read-write
serviceAmqpTlsListenPort|global/read-write
serviceMqttMaxConnectionCount|global/read-write
serviceMqttPlainTextListenPort|global/read-write
serviceMqttTlsListenPort|global/read-write
serviceMqttTlsWebSocketListenPort|global/read-write
serviceMqttWebSocketListenPort|global/read-write
serviceRestIncomingMaxConnectionCount|global/read-write
serviceRestIncomingPlainTextListenPort|global/read-write
serviceRestIncomingTlsListenPort|global/read-write
serviceRestOutgoingMaxConnectionCount|global/read-write
serviceSmfMaxConnectionCount|global/read-write
serviceWebMaxConnectionCount|global/read-write



This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpn(params *ReplaceMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpn",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnACLProfile replaces an ACL profile object

  Replace an ACL Profile object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

An ACL Profile controls whether an authenticated client is permitted to establish a connection with the message broker or permitted to publish and subscribe to specific topics.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x|x||||
msgVpnName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnACLProfile(params *ReplaceMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnACLProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnACLProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnAclProfile",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnACLProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnACLProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnACLProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnAuthenticationOauthProvider replaces an o auth provider object

  Replace an OAuth Provider object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

OAuth Providers contain information about the issuer of an OAuth token that is needed to validate the token and derive a client username from it.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
oauthProviderName|x|x||||
tokenIntrospectionPassword|||x|||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.13.
*/
func (a *Client) ReplaceMsgVpnAuthenticationOauthProvider(params *ReplaceMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnAuthenticationOauthProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnAuthenticationOauthProviderParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnAuthenticationOauthProvider",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/authenticationOauthProviders/{oauthProviderName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnAuthenticationOauthProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnAuthenticationOauthProviderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnAuthenticationOauthProviderDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnAuthorizationGroup replaces an l d a p authorization group object

  Replace an LDAP Authorization Group object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

To use client authorization groups configured on an external LDAP server to provide client authorizations, LDAP Authorization Group objects must be created on the Message VPN that match the authorization groups provisioned on the LDAP server. These objects must be configured with the client profiles and ACL profiles that will be assigned to the clients that belong to those authorization groups. A newly created group is placed at the end of the group list which is the lowest priority.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName||||x||
authorizationGroupName|x|x||||
clientProfileName||||x||
msgVpnName|x|x||||
orderAfterAuthorizationGroupName|||x|||
orderBeforeAuthorizationGroupName|||x|||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnAuthorizationGroup|orderAfterAuthorizationGroupName||orderBeforeAuthorizationGroupName
MsgVpnAuthorizationGroup|orderBeforeAuthorizationGroupName||orderAfterAuthorizationGroupName



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnAuthorizationGroup(params *ReplaceMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnAuthorizationGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnAuthorizationGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnAuthorizationGroup",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/authorizationGroups/{authorizationGroupName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnAuthorizationGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnAuthorizationGroupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnAuthorizationGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnBridge replaces a bridge object

  Replace a Bridge object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

Bridges can be used to link two Message VPNs so that messages published to one Message VPN that match the topic subscriptions set for the bridge are also delivered to the linked Message VPN.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgeName|x|x||||
bridgeVirtualRouter|x|x||||
maxTtl||||x||
msgVpnName|x|x||||
remoteAuthenticationBasicClientUsername||||x||
remoteAuthenticationBasicPassword|||x|x||x
remoteAuthenticationClientCertContent|||x|x||x
remoteAuthenticationClientCertPassword|||x|x||
remoteAuthenticationScheme||||x||
remoteDeliverToOnePriority||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnBridge|remoteAuthenticationBasicClientUsername|remoteAuthenticationBasicPassword|
MsgVpnBridge|remoteAuthenticationBasicPassword|remoteAuthenticationBasicClientUsername|
MsgVpnBridge|remoteAuthenticationClientCertPassword|remoteAuthenticationClientCertContent|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnBridge(params *ReplaceMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnBridge",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnBridgeRemoteMsgVpn replaces a remote message v p n object

  Replace a Remote Message VPN object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

The Remote Message VPN is the Message VPN that the Bridge connects to.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgeName|x|x||||
bridgeVirtualRouter|x|x||||
clientUsername||||x||
compressedDataEnabled||||x||
egressFlowWindowSize||||x||
msgVpnName|x|x||||
password|||x|x||x
remoteMsgVpnInterface|x|x||||
remoteMsgVpnLocation|x|x||||
remoteMsgVpnName|x|x||||
tlsEnabled||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnBridgeRemoteMsgVpn|clientUsername|password|
MsgVpnBridgeRemoteMsgVpn|password|clientUsername|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnBridgeRemoteMsgVpn(params *ReplaceMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnBridgeRemoteMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnBridgeRemoteMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnBridgeRemoteMsgVpn",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteMsgVpns/{remoteMsgVpnName},{remoteMsgVpnLocation},{remoteMsgVpnInterface}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnBridgeRemoteMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnBridgeRemoteMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnBridgeRemoteMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnClientProfile replaces a client profile object

  Replace a Client Profile object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

Client Profiles are used to assign common configuration properties to clients that have been successfully authorized.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
apiQueueManagementCopyFromOnCreateName|||||x|
apiTopicEndpointManagementCopyFromOnCreateName|||||x|
clientProfileName|x|x||||
msgVpnName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent
EventThresholdByPercent|clearPercent|setPercent|
EventThresholdByPercent|setPercent|clearPercent|



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnClientProfile(params *ReplaceMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnClientProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnClientProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnClientProfile",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/clientProfiles/{clientProfileName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnClientProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnClientProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnClientProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnClientUsername replaces a client username object

  Replace a Client Username object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A client is only authorized to connect to a Message VPN that is associated with a Client Username that the client has been assigned.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName||||x||
clientProfileName||||x||
clientUsername|x|x||||
msgVpnName|x|x||||
password|||x|||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnClientUsername(params *ReplaceMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnClientUsernameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnClientUsernameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnClientUsername",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/clientUsernames/{clientUsername}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnClientUsernameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnClientUsernameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnClientUsernameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnDistributedCache replaces a distributed cache object

  Replace a Distributed Cache object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Distributed Cache is a collection of one or more Cache Clusters that belong to the same Message VPN. Each Cache Cluster in a Distributed Cache is configured to subscribe to a different set of topics. This effectively divides up the configured topic space, to provide scaling to very large topic spaces or very high cached message throughput.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
msgVpnName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnDistributedCache|scheduledDeleteMsgDayList|scheduledDeleteMsgTimeList|
MsgVpnDistributedCache|scheduledDeleteMsgTimeList|scheduledDeleteMsgDayList|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) ReplaceMsgVpnDistributedCache(params *ReplaceMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnDistributedCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnDistributedCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnDistributedCache",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnDistributedCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnDistributedCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnDistributedCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnDistributedCacheCluster replaces a cache cluster object

  Replace a Cache Cluster object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Cache Cluster is a collection of one or more Cache Instances that subscribe to exactly the same topics. Cache Instances are grouped together in a Cache Cluster for the purpose of fault tolerance and load balancing. As published messages are received, the message broker message bus sends these live data messages to the Cache Instances in the Cache Cluster. This enables client cache requests to be served by any of Cache Instances in the Cache Cluster.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
clusterName|x|x||||
msgVpnName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThresholdByPercent|clearPercent|setPercent|
EventThresholdByPercent|setPercent|clearPercent|
EventThresholdByValue|clearValue|setValue|
EventThresholdByValue|setValue|clearValue|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) ReplaceMsgVpnDistributedCacheCluster(params *ReplaceMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnDistributedCacheClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnDistributedCacheClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnDistributedCacheCluster",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnDistributedCacheClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnDistributedCacheClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnDistributedCacheClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnDistributedCacheClusterInstance replaces a cache instance object

  Replace a Cache Instance object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Cache Instance is a single Cache process that belongs to a single Cache Cluster. A Cache Instance object provisioned on the broker is used to disseminate configuration information to the Cache process. Cache Instances listen for and cache live data messages that match the topic subscriptions configured for their parent Cache Cluster.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
clusterName|x|x||||
instanceName|x|x||||
msgVpnName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) ReplaceMsgVpnDistributedCacheClusterInstance(params *ReplaceMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnDistributedCacheClusterInstanceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnDistributedCacheClusterInstanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnDistributedCacheClusterInstance",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/instances/{instanceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnDistributedCacheClusterInstanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnDistributedCacheClusterInstanceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnDistributedCacheClusterInstanceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnDmrBridge replaces a d m r bridge object

  Replace a DMR Bridge object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A DMR Bridge is required to establish a data channel over a corresponding external link to the remote node for a given Message VPN. Each DMR Bridge identifies which external link the Message VPN should use, and what the name of the equivalent Message VPN at the remote node is.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
remoteNodeName|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) ReplaceMsgVpnDmrBridge(params *ReplaceMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnDmrBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnDmrBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnDmrBridge",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/dmrBridges/{remoteNodeName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnDmrBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnDmrBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnDmrBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnJndiConnectionFactory replaces a j n d i connection factory object

  Replace a JNDI Connection Factory object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

The message broker provides an internal JNDI store for provisioned Connection Factory objects that clients can access through JNDI lookups.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
connectionFactoryName|x|x||||
msgVpnName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) ReplaceMsgVpnJndiConnectionFactory(params *ReplaceMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnJndiConnectionFactoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnJndiConnectionFactoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnJndiConnectionFactory",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiConnectionFactories/{connectionFactoryName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnJndiConnectionFactoryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnJndiConnectionFactoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnJndiConnectionFactoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnJndiQueue replaces a j n d i queue object

  Replace a JNDI Queue object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

The message broker provides an internal JNDI store for provisioned Queue objects that clients can access through JNDI lookups.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
queueName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) ReplaceMsgVpnJndiQueue(params *ReplaceMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnJndiQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnJndiQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnJndiQueue",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiQueues/{queueName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnJndiQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnJndiQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnJndiQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnJndiTopic replaces a j n d i topic object

  Replace a JNDI Topic object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

The message broker provides an internal JNDI store for provisioned Topic objects that clients can access through JNDI lookups.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
topicName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) ReplaceMsgVpnJndiTopic(params *ReplaceMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnJndiTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnJndiTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnJndiTopic",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiTopics/{topicName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnJndiTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnJndiTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnJndiTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnMqttRetainCache replaces an m q t t retain cache object

  Replace an MQTT Retain Cache object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

Using MQTT retained messages allows publishing MQTT clients to indicate that a message must be stored for later delivery to subscribing clients when those subscribing clients add subscriptions matching the retained message's topic. An MQTT Retain Cache processes all retained messages for a Message VPN.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
msgVpnName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) ReplaceMsgVpnMqttRetainCache(params *ReplaceMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnMqttRetainCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnMqttRetainCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnMqttRetainCache",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttRetainCaches/{cacheName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnMqttRetainCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnMqttRetainCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnMqttRetainCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnMqttSession replaces an m q t t session object

  Replace an MQTT Session object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

An MQTT Session object is a virtual representation of an MQTT client connection. An MQTT session holds the state of an MQTT client (that is, it is used to contain a client's QoS 0 and QoS 1 subscription sets and any undelivered QoS 1 messages).


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
mqttSessionClientId|x|x||||
mqttSessionVirtualRouter|x|x||||
msgVpnName|x|x||||
owner||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) ReplaceMsgVpnMqttSession(params *ReplaceMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnMqttSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnMqttSessionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnMqttSession",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnMqttSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnMqttSessionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnMqttSessionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnMqttSessionSubscription replaces a subscription object

  Replace a Subscription object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

An MQTT session contains a client's QoS 0 and QoS 1 subscription sets. On creation, a subscription defaults to QoS 0.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
mqttSessionClientId|x|x||||
mqttSessionVirtualRouter|x|x||||
msgVpnName|x|x||||
subscriptionTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) ReplaceMsgVpnMqttSessionSubscription(params *ReplaceMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnMqttSessionSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnMqttSessionSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnMqttSessionSubscription",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}/subscriptions/{subscriptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnMqttSessionSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnMqttSessionSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnMqttSessionSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnQueue replaces a queue object

  Replace a Queue object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Queue acts as both a destination that clients can publish messages to, and as an endpoint that clients can bind consumers to and consume messages from.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
accessType||||x||
msgVpnName|x|x||||
owner||||x||
permission||||x||
queueName|x|x||||
respectMsgPriorityEnabled||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnQueue(params *ReplaceMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnQueue",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/queues/{queueName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnQueueTemplate replaces a queue template object

  Replace a Queue Template object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Queue Template provides a mechanism for specifying the initial state for client created queues.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
queueTemplateName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) ReplaceMsgVpnQueueTemplate(params *ReplaceMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnQueueTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnQueueTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnQueueTemplate",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/queueTemplates/{queueTemplateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnQueueTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnQueueTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnQueueTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnReplayLog replaces a replay log object

  Replace a Replay Log object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

When the Message Replay feature is enabled, message brokers store persistent messages in a Replay Log. These messages are kept until the log is full, after which the oldest messages are removed to free up space for new messages.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
replayLogName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.10.
*/
func (a *Client) ReplaceMsgVpnReplayLog(params *ReplaceMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnReplayLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnReplayLogParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnReplayLog",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/replayLogs/{replayLogName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnReplayLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnReplayLogOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnReplayLogDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnReplicatedTopic replaces a replicated topic object

  Replace a Replicated Topic object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

To indicate which messages should be replicated between the active and standby site, a Replicated Topic subscription must be configured on a Message VPN. If a published message matches both a replicated topic and an endpoint on the active site, then the message is replicated to the standby site.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
replicatedTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) ReplaceMsgVpnReplicatedTopic(params *ReplaceMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnReplicatedTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnReplicatedTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnReplicatedTopic",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/replicatedTopics/{replicatedTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnReplicatedTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnReplicatedTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnReplicatedTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnRestDeliveryPoint replaces a r e s t delivery point object

  Replace a REST Delivery Point object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A REST Delivery Point manages delivery of messages from queues to a named list of REST Consumers.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
clientProfileName||||x||
msgVpnName|x|x||||
restDeliveryPointName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnRestDeliveryPoint(params *ReplaceMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnRestDeliveryPointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnRestDeliveryPointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnRestDeliveryPoint",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnRestDeliveryPointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnRestDeliveryPointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnRestDeliveryPointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnRestDeliveryPointQueueBinding replaces a queue binding object

  Replace a Queue Binding object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Queue Binding for a REST Delivery Point attracts messages to be delivered to REST consumers. If the queue does not exist it can be created subsequently, and once the queue is operational the broker performs the queue binding. Removing the queue binding does not delete the queue itself. Similarly, removing the queue does not remove the queue binding, which fails until the queue is recreated or the queue binding is deleted.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
queueBindingName|x|x||||
restDeliveryPointName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnRestDeliveryPointQueueBinding(params *ReplaceMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnRestDeliveryPointQueueBindingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnRestDeliveryPointQueueBindingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnRestDeliveryPointQueueBinding",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/queueBindings/{queueBindingName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnRestDeliveryPointQueueBindingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnRestDeliveryPointQueueBindingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnRestDeliveryPointQueueBindingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnRestDeliveryPointRestConsumer replaces a r e s t consumer object

  Replace a REST Consumer object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

REST Consumer objects establish HTTP connectivity to REST consumer applications who wish to receive messages from a broker.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationClientCertContent|||x|x||x
authenticationClientCertPassword|||x|x||
authenticationHttpBasicPassword|||x|x||x
authenticationHttpBasicUsername||||x||
authenticationHttpHeaderValue|||x|||x
authenticationOauthClientId||||x||
authenticationOauthClientScope||||x||
authenticationOauthClientSecret|||x|x||x
authenticationOauthClientTokenEndpoint||||x||
authenticationOauthJwtSecretKey|||x|x||x
authenticationOauthJwtTokenEndpoint||||x||
authenticationScheme||||x||
msgVpnName|x|x||||
outgoingConnectionCount||||x||
remoteHost||||x||
remotePort||||x||
restConsumerName|x|x||||
restDeliveryPointName|x|x||||
tlsCipherSuiteList||||x||
tlsEnabled||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnRestDeliveryPointRestConsumer|authenticationClientCertPassword|authenticationClientCertContent|
MsgVpnRestDeliveryPointRestConsumer|authenticationHttpBasicPassword|authenticationHttpBasicUsername|
MsgVpnRestDeliveryPointRestConsumer|authenticationHttpBasicUsername|authenticationHttpBasicPassword|
MsgVpnRestDeliveryPointRestConsumer|remotePort|tlsEnabled|
MsgVpnRestDeliveryPointRestConsumer|tlsEnabled|remotePort|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) ReplaceMsgVpnRestDeliveryPointRestConsumer(params *ReplaceMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnRestDeliveryPointRestConsumerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnRestDeliveryPointRestConsumerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnRestDeliveryPointRestConsumer",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnRestDeliveryPointRestConsumerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnRestDeliveryPointRestConsumerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnRestDeliveryPointRestConsumerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnTopicEndpoint replaces a topic endpoint object

  Replace a Topic Endpoint object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Topic Endpoint attracts messages published to a topic for which the Topic Endpoint has a matching topic subscription. The topic subscription for the Topic Endpoint is specified in the client request to bind a Flow to that Topic Endpoint. Queues are significantly more flexible than Topic Endpoints and are the recommended approach for most applications. The use of Topic Endpoints should be restricted to JMS applications.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
accessType||||x||
msgVpnName|x|x||||
owner||||x||
permission||||x||
respectMsgPriorityEnabled||||x||
topicEndpointName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) ReplaceMsgVpnTopicEndpoint(params *ReplaceMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnTopicEndpointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnTopicEndpointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnTopicEndpoint",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpoints/{topicEndpointName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnTopicEndpointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnTopicEndpointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnTopicEndpointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceMsgVpnTopicEndpointTemplate replaces a topic endpoint template object

  Replace a Topic Endpoint Template object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Topic Endpoint Template provides a mechanism for specifying the initial state for client created topic endpoints.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
topicEndpointTemplateName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) ReplaceMsgVpnTopicEndpointTemplate(params *ReplaceMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceMsgVpnTopicEndpointTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceMsgVpnTopicEndpointTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceMsgVpnTopicEndpointTemplate",
		Method:             "PUT",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpointTemplates/{topicEndpointTemplateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceMsgVpnTopicEndpointTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceMsgVpnTopicEndpointTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceMsgVpnTopicEndpointTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ReplaceVirtualHostname replaces a virtual hostname object

  Replace a Virtual Hostname object. Any attribute missing from the request will be set to its default value, subject to the exceptions in note 4.

A Virtual Hostname is a provisioned object on a message broker that contains a Virtual Hostname to Message VPN mapping.

Clients which connect to a global (as opposed to per Message VPN) port and provides this hostname will be directed to its corresponding Message VPN. A case-insentive match is performed on the full client-provided hostname against the configured virtual-hostname.

This mechanism is only supported for hostnames provided through the Server Name Indication (SNI) extension of TLS.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
virtualHostname|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.17.
*/
func (a *Client) ReplaceVirtualHostname(params *ReplaceVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplaceVirtualHostnameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceVirtualHostnameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceVirtualHostname",
		Method:             "PUT",
		PathPattern:        "/virtualHostnames/{virtualHostname}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReplaceVirtualHostnameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceVirtualHostnameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceVirtualHostnameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateBroker updates a broker object

  Update a Broker object. Any attribute missing from the request will be left unchanged.

This object contains global configuration for the message broker.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
serviceAmqpTlsListenPort||||x||
serviceHealthCheckListenPort||||x||
serviceMateLinkListenPort||||x||
serviceRedundancyFirstListenPort||||x||
serviceSempPlainTextListenPort||||x||
serviceSempTlsListenPort||||x||
serviceSmfCompressionListenPort||||x||
serviceSmfPlainTextListenPort||||x||
serviceSmfRoutingControlListenPort||||x||
serviceSmfTlsListenPort||||x||
serviceWebTransportPlainTextListenPort||||x||
serviceWebTransportTlsListenPort||||x||
serviceWebTransportWebUrlSuffix||||x||
tlsServerCertContent|||x|||x
tlsServerCertPassword|||x|||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
Broker|tlsServerCertPassword|tlsServerCertContent|
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent
EventThresholdByPercent|clearPercent|setPercent|
EventThresholdByPercent|setPercent|clearPercent|



A SEMP client authorized with a minimum access scope/level of "global/none" is required to perform this operation. Requests which include the following attributes require greater access scope/level:


Attribute|Access Scope/Level
:---|:---:
authClientCertRevocationCheckMode|global/admin
guaranteedMsgingEnabled|global/read-write
guaranteedMsgingEventCacheUsageThreshold.clearPercent|global/read-write
guaranteedMsgingEventCacheUsageThreshold.clearValue|global/read-write
guaranteedMsgingEventCacheUsageThreshold.setPercent|global/read-write
guaranteedMsgingEventCacheUsageThreshold.setValue|global/read-write
guaranteedMsgingEventDeliveredUnackedThreshold.clearPercent|global/read-write
guaranteedMsgingEventDeliveredUnackedThreshold.setPercent|global/read-write
guaranteedMsgingEventDiskUsageThreshold.clearPercent|global/read-write
guaranteedMsgingEventDiskUsageThreshold.setPercent|global/read-write
guaranteedMsgingEventEgressFlowCountThreshold.clearPercent|global/read-write
guaranteedMsgingEventEgressFlowCountThreshold.clearValue|global/read-write
guaranteedMsgingEventEgressFlowCountThreshold.setPercent|global/read-write
guaranteedMsgingEventEgressFlowCountThreshold.setValue|global/read-write
guaranteedMsgingEventEndpointCountThreshold.clearPercent|global/read-write
guaranteedMsgingEventEndpointCountThreshold.clearValue|global/read-write
guaranteedMsgingEventEndpointCountThreshold.setPercent|global/read-write
guaranteedMsgingEventEndpointCountThreshold.setValue|global/read-write
guaranteedMsgingEventIngressFlowCountThreshold.clearPercent|global/read-write
guaranteedMsgingEventIngressFlowCountThreshold.clearValue|global/read-write
guaranteedMsgingEventIngressFlowCountThreshold.setPercent|global/read-write
guaranteedMsgingEventIngressFlowCountThreshold.setValue|global/read-write
guaranteedMsgingEventMsgCountThreshold.clearPercent|global/read-write
guaranteedMsgingEventMsgCountThreshold.setPercent|global/read-write
guaranteedMsgingEventMsgSpoolFileCountThreshold.clearPercent|global/read-write
guaranteedMsgingEventMsgSpoolFileCountThreshold.setPercent|global/read-write
guaranteedMsgingEventMsgSpoolUsageThreshold.clearPercent|global/read-write
guaranteedMsgingEventMsgSpoolUsageThreshold.clearValue|global/read-write
guaranteedMsgingEventMsgSpoolUsageThreshold.setPercent|global/read-write
guaranteedMsgingEventMsgSpoolUsageThreshold.setValue|global/read-write
guaranteedMsgingEventTransactedSessionCountThreshold.clearPercent|global/read-write
guaranteedMsgingEventTransactedSessionCountThreshold.clearValue|global/read-write
guaranteedMsgingEventTransactedSessionCountThreshold.setPercent|global/read-write
guaranteedMsgingEventTransactedSessionCountThreshold.setValue|global/read-write
guaranteedMsgingEventTransactedSessionResourceCountThreshold.clearPercent|global/read-write
guaranteedMsgingEventTransactedSessionResourceCountThreshold.setPercent|global/read-write
guaranteedMsgingEventTransactionCountThreshold.clearPercent|global/read-write
guaranteedMsgingEventTransactionCountThreshold.clearValue|global/read-write
guaranteedMsgingEventTransactionCountThreshold.setPercent|global/read-write
guaranteedMsgingEventTransactionCountThreshold.setValue|global/read-write
guaranteedMsgingMaxCacheUsage|global/read-write
guaranteedMsgingMaxMsgSpoolUsage|global/read-write
guaranteedMsgingMsgSpoolSyncMirroredMsgAckTimeout|global/read-write
guaranteedMsgingMsgSpoolSyncMirroredSpoolFileAckTimeout|global/read-write
guaranteedMsgingTransactionReplicationCompatibilityMode|global/read-write
serviceAmqpEnabled|global/read-write
serviceAmqpTlsListenPort|global/read-write
serviceEventConnectionCountThreshold.clearPercent|global/read-write
serviceEventConnectionCountThreshold.clearValue|global/read-write
serviceEventConnectionCountThreshold.setPercent|global/read-write
serviceEventConnectionCountThreshold.setValue|global/read-write
serviceHealthCheckEnabled|global/read-write
serviceHealthCheckListenPort|global/read-write
serviceMateLinkEnabled|global/read-write
serviceMateLinkListenPort|global/read-write
serviceMqttEnabled|global/read-write
serviceMsgBackboneEnabled|global/read-write
serviceRedundancyEnabled|global/read-write
serviceRedundancyFirstListenPort|global/read-write
serviceRestEventOutgoingConnectionCountThreshold.clearPercent|global/read-write
serviceRestEventOutgoingConnectionCountThreshold.clearValue|global/read-write
serviceRestEventOutgoingConnectionCountThreshold.setPercent|global/read-write
serviceRestEventOutgoingConnectionCountThreshold.setValue|global/read-write
serviceRestIncomingEnabled|global/read-write
serviceRestOutgoingEnabled|global/read-write
serviceSempLegacyTimeoutEnabled|global/read-write
serviceSempPlainTextEnabled|global/read-write
serviceSempPlainTextListenPort|global/read-write
serviceSempSessionIdleTimeout|global/read-write
serviceSempSessionMaxLifetime|global/read-write
serviceSempTlsEnabled|global/read-write
serviceSempTlsListenPort|global/read-write
serviceSmfCompressionListenPort|global/read-write
serviceSmfEnabled|global/read-write
serviceSmfEventConnectionCountThreshold.clearPercent|global/read-write
serviceSmfEventConnectionCountThreshold.clearValue|global/read-write
serviceSmfEventConnectionCountThreshold.setPercent|global/read-write
serviceSmfEventConnectionCountThreshold.setValue|global/read-write
serviceSmfPlainTextListenPort|global/read-write
serviceSmfRoutingControlListenPort|global/read-write
serviceSmfTlsListenPort|global/read-write
serviceTlsEventConnectionCountThreshold.clearPercent|global/read-write
serviceTlsEventConnectionCountThreshold.clearValue|global/read-write
serviceTlsEventConnectionCountThreshold.setPercent|global/read-write
serviceTlsEventConnectionCountThreshold.setValue|global/read-write
serviceWebTransportEnabled|global/read-write
serviceWebTransportPlainTextListenPort|global/read-write
serviceWebTransportTlsListenPort|global/read-write
serviceWebTransportWebUrlSuffix|global/read-write
tlsBlockVersion11Enabled|global/read-write
tlsCipherSuiteManagementList|global/read-write
tlsCipherSuiteMsgBackboneList|global/read-write
tlsCipherSuiteSecureShellList|global/read-write
tlsCrimeExploitProtectionEnabled|global/read-write
tlsServerCertContent|global/read-write
tlsServerCertPassword|global/read-write
tlsStandardDomainCertificateAuthoritiesEnabled|global/read-write
tlsTicketLifetime|global/read-write



This has been available since 2.13.
*/
func (a *Client) UpdateBroker(params *UpdateBrokerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateBrokerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateBrokerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateBroker",
		Method:             "PATCH",
		PathPattern:        "/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateBrokerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateBrokerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateBrokerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateCertAuthority updates a certificate authority object

  Update a Certificate Authority object. Any attribute missing from the request will be left unchanged.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x|||x|
certContent|||||x|
crlDayList|||||x|
crlTimeList|||||x|
crlUrl||||x|x|
ocspNonResponderCertEnabled|||||x|
ocspOverrideUrl|||||x|
ocspTimeout|||||x|
revocationCheckEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
CertAuthority|crlDayList|crlTimeList|
CertAuthority|crlTimeList|crlDayList|



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been deprecated since 2.19. Replaced by clientCertAuthorities and domainCertAuthorities.
*/
func (a *Client) UpdateCertAuthority(params *UpdateCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateCertAuthority",
		Method:             "PATCH",
		PathPattern:        "/certAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateClientCertAuthority updates a client certificate authority object

  Update a Client Certificate Authority object. Any attribute missing from the request will be left unchanged.

Clients can authenticate with the message broker over TLS by presenting a valid client certificate. The message broker authenticates the client certificate by constructing a full certificate chain (from the client certificate to intermediate CAs to a configured root CA). The intermediate CAs in this chain can be provided by the client, or configured in the message broker. The root CA must be configured on the message broker.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x||||
crlUrl||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
ClientCertAuthority|crlDayList|crlTimeList|
ClientCertAuthority|crlTimeList|crlDayList|



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) UpdateClientCertAuthority(params *UpdateClientCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClientCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClientCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateClientCertAuthority",
		Method:             "PATCH",
		PathPattern:        "/clientCertAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateClientCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClientCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClientCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateDmrCluster updates a cluster object

  Update a Cluster object. Any attribute missing from the request will be left unchanged.

A Cluster is a provisioned object on a message broker that contains global DMR configuration parameters.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationBasicPassword|||x|x||x
authenticationClientCertContent|||x|x||x
authenticationClientCertPassword|||x|x||
directOnlyEnabled||x||||
dmrClusterName|x|x||||
nodeName||x||||
tlsServerCertEnforceTrustedCommonNameEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
DmrCluster|authenticationClientCertPassword|authenticationClientCertContent|



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) UpdateDmrCluster(params *UpdateDmrClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateDmrClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDmrClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateDmrCluster",
		Method:             "PATCH",
		PathPattern:        "/dmrClusters/{dmrClusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateDmrClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateDmrClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateDmrClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateDmrClusterLink updates a link object

  Update a Link object. Any attribute missing from the request will be left unchanged.

A Link connects nodes (either within a Cluster or between two different Clusters) and allows them to exchange topology information, subscriptions and data.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationBasicPassword|||x|x||x
authenticationScheme||||x||
dmrClusterName|x|x||||
egressFlowWindowSize||||x||
initiator||||x||
remoteNodeName|x|x||||
span||||x||
transportCompressedEnabled||||x||
transportTlsEnabled||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) UpdateDmrClusterLink(params *UpdateDmrClusterLinkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateDmrClusterLinkOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDmrClusterLinkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateDmrClusterLink",
		Method:             "PATCH",
		PathPattern:        "/dmrClusters/{dmrClusterName}/links/{remoteNodeName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateDmrClusterLinkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateDmrClusterLinkOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateDmrClusterLinkDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateDomainCertAuthority updates a domain certificate authority object

  Update a Domain Certificate Authority object. Any attribute missing from the request will be left unchanged.

Certificate Authorities trusted for domain verification.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
certAuthorityName|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/admin" is required to perform this operation.

This has been available since 2.19.
*/
func (a *Client) UpdateDomainCertAuthority(params *UpdateDomainCertAuthorityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateDomainCertAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDomainCertAuthorityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateDomainCertAuthority",
		Method:             "PATCH",
		PathPattern:        "/domainCertAuthorities/{certAuthorityName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateDomainCertAuthorityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateDomainCertAuthorityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateDomainCertAuthorityDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpn updates a message v p n object

  Update a Message VPN object. Any attribute missing from the request will be left unchanged.

Message VPNs (Virtual Private Networks) allow for the segregation of topic space and clients. They also group clients connecting to a network of message brokers, such that messages published within a particular group are only visible to that group's clients.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgingTlsServerCertEnforceTrustedCommonNameEnabled|||||x|
msgVpnName|x|x||||
replicationBridgeAuthenticationBasicPassword|||x|||x
replicationBridgeAuthenticationClientCertContent|||x|||x
replicationBridgeAuthenticationClientCertPassword|||x|||
replicationEnabledQueueBehavior|||x|||
restTlsServerCertEnforceTrustedCommonNameEnabled|||||x|



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent
EventThresholdByValue|clearValue|setValue|
EventThresholdByValue|setValue|clearValue|
MsgVpn|authenticationBasicProfileName|authenticationBasicType|
MsgVpn|authorizationProfileName|authorizationType|
MsgVpn|eventPublishTopicFormatMqttEnabled|eventPublishTopicFormatSmfEnabled|
MsgVpn|eventPublishTopicFormatSmfEnabled|eventPublishTopicFormatMqttEnabled|
MsgVpn|replicationBridgeAuthenticationBasicClientUsername|replicationBridgeAuthenticationBasicPassword|
MsgVpn|replicationBridgeAuthenticationBasicPassword|replicationBridgeAuthenticationBasicClientUsername|
MsgVpn|replicationBridgeAuthenticationClientCertPassword|replicationBridgeAuthenticationClientCertContent|
MsgVpn|replicationEnabledQueueBehavior|replicationEnabled|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation. Requests which include the following attributes require greater access scope/level:


Attribute|Access Scope/Level
:---|:---:
alias|global/read-write
authenticationBasicEnabled|global/read-write
authenticationBasicProfileName|global/read-write
authenticationBasicRadiusDomain|global/read-write
authenticationBasicType|global/read-write
authenticationClientCertAllowApiProvidedUsernameEnabled|global/read-write
authenticationClientCertEnabled|global/read-write
authenticationClientCertMaxChainDepth|global/read-write
authenticationClientCertRevocationCheckMode|global/read-write
authenticationClientCertUsernameSource|global/read-write
authenticationClientCertValidateDateEnabled|global/read-write
authenticationKerberosAllowApiProvidedUsernameEnabled|global/read-write
authenticationKerberosEnabled|global/read-write
authenticationOauthEnabled|global/read-write
bridgingTlsServerCertEnforceTrustedCommonNameEnabled|global/read-write
bridgingTlsServerCertMaxChainDepth|global/read-write
bridgingTlsServerCertValidateDateEnabled|global/read-write
bridgingTlsServerCertValidateNameEnabled|global/read-write
dmrEnabled|global/read-write
exportSubscriptionsEnabled|global/read-write
maxConnectionCount|global/read-write
maxEgressFlowCount|global/read-write
maxEndpointCount|global/read-write
maxIngressFlowCount|global/read-write
maxMsgSpoolUsage|global/read-write
maxSubscriptionCount|global/read-write
maxTransactedSessionCount|global/read-write
maxTransactionCount|global/read-write
mqttRetainMaxMemory|global/read-write
replicationBridgeAuthenticationBasicClientUsername|global/read-write
replicationBridgeAuthenticationBasicPassword|global/read-write
replicationBridgeAuthenticationClientCertContent|global/read-write
replicationBridgeAuthenticationClientCertPassword|global/read-write
replicationBridgeAuthenticationScheme|global/read-write
replicationBridgeCompressedDataEnabled|global/read-write
replicationBridgeEgressFlowWindowSize|global/read-write
replicationBridgeRetryDelay|global/read-write
replicationBridgeTlsEnabled|global/read-write
replicationBridgeUnidirectionalClientProfileName|global/read-write
replicationEnabled|global/read-write
replicationEnabledQueueBehavior|global/read-write
replicationQueueMaxMsgSpoolUsage|global/read-write
replicationRole|global/read-write
restTlsServerCertEnforceTrustedCommonNameEnabled|global/read-write
restTlsServerCertMaxChainDepth|global/read-write
restTlsServerCertValidateDateEnabled|global/read-write
restTlsServerCertValidateNameEnabled|global/read-write
sempOverMsgBusAdminClientEnabled|global/read-write
sempOverMsgBusAdminDistributedCacheEnabled|global/read-write
sempOverMsgBusAdminEnabled|global/read-write
sempOverMsgBusEnabled|global/read-write
sempOverMsgBusShowEnabled|global/read-write
serviceAmqpMaxConnectionCount|global/read-write
serviceAmqpPlainTextListenPort|global/read-write
serviceAmqpTlsListenPort|global/read-write
serviceMqttMaxConnectionCount|global/read-write
serviceMqttPlainTextListenPort|global/read-write
serviceMqttTlsListenPort|global/read-write
serviceMqttTlsWebSocketListenPort|global/read-write
serviceMqttWebSocketListenPort|global/read-write
serviceRestIncomingMaxConnectionCount|global/read-write
serviceRestIncomingPlainTextListenPort|global/read-write
serviceRestIncomingTlsListenPort|global/read-write
serviceRestOutgoingMaxConnectionCount|global/read-write
serviceSmfMaxConnectionCount|global/read-write
serviceWebMaxConnectionCount|global/read-write



This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpn(params *UpdateMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpn",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnACLProfile updates an ACL profile object

  Update an ACL Profile object. Any attribute missing from the request will be left unchanged.

An ACL Profile controls whether an authenticated client is permitted to establish a connection with the message broker or permitted to publish and subscribe to specific topics.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName|x|x||||
msgVpnName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnACLProfile(params *UpdateMsgVpnACLProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnACLProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnACLProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnAclProfile",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/aclProfiles/{aclProfileName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnACLProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnACLProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnACLProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnAuthenticationOauthProvider updates an o auth provider object

  Update an OAuth Provider object. Any attribute missing from the request will be left unchanged.

OAuth Providers contain information about the issuer of an OAuth token that is needed to validate the token and derive a client username from it.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
oauthProviderName|x|x||||
tokenIntrospectionPassword|||x|||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.13.
*/
func (a *Client) UpdateMsgVpnAuthenticationOauthProvider(params *UpdateMsgVpnAuthenticationOauthProviderParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnAuthenticationOauthProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnAuthenticationOauthProviderParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnAuthenticationOauthProvider",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/authenticationOauthProviders/{oauthProviderName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnAuthenticationOauthProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnAuthenticationOauthProviderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnAuthenticationOauthProviderDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnAuthorizationGroup updates an l d a p authorization group object

  Update an LDAP Authorization Group object. Any attribute missing from the request will be left unchanged.

To use client authorization groups configured on an external LDAP server to provide client authorizations, LDAP Authorization Group objects must be created on the Message VPN that match the authorization groups provisioned on the LDAP server. These objects must be configured with the client profiles and ACL profiles that will be assigned to the clients that belong to those authorization groups. A newly created group is placed at the end of the group list which is the lowest priority.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName||||x||
authorizationGroupName|x|x||||
clientProfileName||||x||
msgVpnName|x|x||||
orderAfterAuthorizationGroupName|||x|||
orderBeforeAuthorizationGroupName|||x|||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnAuthorizationGroup|orderAfterAuthorizationGroupName||orderBeforeAuthorizationGroupName
MsgVpnAuthorizationGroup|orderBeforeAuthorizationGroupName||orderAfterAuthorizationGroupName



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnAuthorizationGroup(params *UpdateMsgVpnAuthorizationGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnAuthorizationGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnAuthorizationGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnAuthorizationGroup",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/authorizationGroups/{authorizationGroupName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnAuthorizationGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnAuthorizationGroupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnAuthorizationGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnBridge updates a bridge object

  Update a Bridge object. Any attribute missing from the request will be left unchanged.

Bridges can be used to link two Message VPNs so that messages published to one Message VPN that match the topic subscriptions set for the bridge are also delivered to the linked Message VPN.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgeName|x|x||||
bridgeVirtualRouter|x|x||||
maxTtl||||x||
msgVpnName|x|x||||
remoteAuthenticationBasicClientUsername||||x||
remoteAuthenticationBasicPassword|||x|x||x
remoteAuthenticationClientCertContent|||x|x||x
remoteAuthenticationClientCertPassword|||x|x||
remoteAuthenticationScheme||||x||
remoteDeliverToOnePriority||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnBridge|remoteAuthenticationBasicClientUsername|remoteAuthenticationBasicPassword|
MsgVpnBridge|remoteAuthenticationBasicPassword|remoteAuthenticationBasicClientUsername|
MsgVpnBridge|remoteAuthenticationClientCertPassword|remoteAuthenticationClientCertContent|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnBridge(params *UpdateMsgVpnBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnBridge",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnBridgeRemoteMsgVpn updates a remote message v p n object

  Update a Remote Message VPN object. Any attribute missing from the request will be left unchanged.

The Remote Message VPN is the Message VPN that the Bridge connects to.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
bridgeName|x|x||||
bridgeVirtualRouter|x|x||||
clientUsername||||x||
compressedDataEnabled||||x||
egressFlowWindowSize||||x||
msgVpnName|x|x||||
password|||x|x||x
remoteMsgVpnInterface|x|x||||
remoteMsgVpnLocation|x|x||||
remoteMsgVpnName|x|x||||
tlsEnabled||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnBridgeRemoteMsgVpn|clientUsername|password|
MsgVpnBridgeRemoteMsgVpn|password|clientUsername|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnBridgeRemoteMsgVpn(params *UpdateMsgVpnBridgeRemoteMsgVpnParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnBridgeRemoteMsgVpnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnBridgeRemoteMsgVpnParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnBridgeRemoteMsgVpn",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/bridges/{bridgeName},{bridgeVirtualRouter}/remoteMsgVpns/{remoteMsgVpnName},{remoteMsgVpnLocation},{remoteMsgVpnInterface}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnBridgeRemoteMsgVpnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnBridgeRemoteMsgVpnOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnBridgeRemoteMsgVpnDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnClientProfile updates a client profile object

  Update a Client Profile object. Any attribute missing from the request will be left unchanged.

Client Profiles are used to assign common configuration properties to clients that have been successfully authorized.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
apiQueueManagementCopyFromOnCreateName|||||x|
apiTopicEndpointManagementCopyFromOnCreateName|||||x|
clientProfileName|x|x||||
msgVpnName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent
EventThresholdByPercent|clearPercent|setPercent|
EventThresholdByPercent|setPercent|clearPercent|



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnClientProfile(params *UpdateMsgVpnClientProfileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnClientProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnClientProfileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnClientProfile",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/clientProfiles/{clientProfileName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnClientProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnClientProfileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnClientProfileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnClientUsername updates a client username object

  Update a Client Username object. Any attribute missing from the request will be left unchanged.

A client is only authorized to connect to a Message VPN that is associated with a Client Username that the client has been assigned.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
aclProfileName||||x||
clientProfileName||||x||
clientUsername|x|x||||
msgVpnName|x|x||||
password|||x|||x



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnClientUsername(params *UpdateMsgVpnClientUsernameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnClientUsernameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnClientUsernameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnClientUsername",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/clientUsernames/{clientUsername}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnClientUsernameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnClientUsernameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnClientUsernameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnDistributedCache updates a distributed cache object

  Update a Distributed Cache object. Any attribute missing from the request will be left unchanged.

A Distributed Cache is a collection of one or more Cache Clusters that belong to the same Message VPN. Each Cache Cluster in a Distributed Cache is configured to subscribe to a different set of topics. This effectively divides up the configured topic space, to provide scaling to very large topic spaces or very high cached message throughput.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
msgVpnName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnDistributedCache|scheduledDeleteMsgDayList|scheduledDeleteMsgTimeList|
MsgVpnDistributedCache|scheduledDeleteMsgTimeList|scheduledDeleteMsgDayList|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) UpdateMsgVpnDistributedCache(params *UpdateMsgVpnDistributedCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnDistributedCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnDistributedCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnDistributedCache",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnDistributedCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnDistributedCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnDistributedCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnDistributedCacheCluster updates a cache cluster object

  Update a Cache Cluster object. Any attribute missing from the request will be left unchanged.

A Cache Cluster is a collection of one or more Cache Instances that subscribe to exactly the same topics. Cache Instances are grouped together in a Cache Cluster for the purpose of fault tolerance and load balancing. As published messages are received, the message broker message bus sends these live data messages to the Cache Instances in the Cache Cluster. This enables client cache requests to be served by any of Cache Instances in the Cache Cluster.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
clusterName|x|x||||
msgVpnName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThresholdByPercent|clearPercent|setPercent|
EventThresholdByPercent|setPercent|clearPercent|
EventThresholdByValue|clearValue|setValue|
EventThresholdByValue|setValue|clearValue|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) UpdateMsgVpnDistributedCacheCluster(params *UpdateMsgVpnDistributedCacheClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnDistributedCacheClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnDistributedCacheClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnDistributedCacheCluster",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnDistributedCacheClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnDistributedCacheClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnDistributedCacheClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnDistributedCacheClusterInstance updates a cache instance object

  Update a Cache Instance object. Any attribute missing from the request will be left unchanged.

A Cache Instance is a single Cache process that belongs to a single Cache Cluster. A Cache Instance object provisioned on the broker is used to disseminate configuration information to the Cache process. Cache Instances listen for and cache live data messages that match the topic subscriptions configured for their parent Cache Cluster.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
clusterName|x|x||||
instanceName|x|x||||
msgVpnName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) UpdateMsgVpnDistributedCacheClusterInstance(params *UpdateMsgVpnDistributedCacheClusterInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnDistributedCacheClusterInstanceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnDistributedCacheClusterInstanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnDistributedCacheClusterInstance",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/distributedCaches/{cacheName}/clusters/{clusterName}/instances/{instanceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnDistributedCacheClusterInstanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnDistributedCacheClusterInstanceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnDistributedCacheClusterInstanceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnDmrBridge updates a d m r bridge object

  Update a DMR Bridge object. Any attribute missing from the request will be left unchanged.

A DMR Bridge is required to establish a data channel over a corresponding external link to the remote node for a given Message VPN. Each DMR Bridge identifies which external link the Message VPN should use, and what the name of the equivalent Message VPN at the remote node is.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
remoteNodeName|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) UpdateMsgVpnDmrBridge(params *UpdateMsgVpnDmrBridgeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnDmrBridgeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnDmrBridgeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnDmrBridge",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/dmrBridges/{remoteNodeName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnDmrBridgeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnDmrBridgeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnDmrBridgeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnJndiConnectionFactory updates a j n d i connection factory object

  Update a JNDI Connection Factory object. Any attribute missing from the request will be left unchanged.

The message broker provides an internal JNDI store for provisioned Connection Factory objects that clients can access through JNDI lookups.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
connectionFactoryName|x|x||||
msgVpnName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) UpdateMsgVpnJndiConnectionFactory(params *UpdateMsgVpnJndiConnectionFactoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnJndiConnectionFactoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnJndiConnectionFactoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnJndiConnectionFactory",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiConnectionFactories/{connectionFactoryName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnJndiConnectionFactoryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnJndiConnectionFactoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnJndiConnectionFactoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnJndiQueue updates a j n d i queue object

  Update a JNDI Queue object. Any attribute missing from the request will be left unchanged.

The message broker provides an internal JNDI store for provisioned Queue objects that clients can access through JNDI lookups.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
queueName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) UpdateMsgVpnJndiQueue(params *UpdateMsgVpnJndiQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnJndiQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnJndiQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnJndiQueue",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiQueues/{queueName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnJndiQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnJndiQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnJndiQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnJndiTopic updates a j n d i topic object

  Update a JNDI Topic object. Any attribute missing from the request will be left unchanged.

The message broker provides an internal JNDI store for provisioned Topic objects that clients can access through JNDI lookups.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
topicName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.2.
*/
func (a *Client) UpdateMsgVpnJndiTopic(params *UpdateMsgVpnJndiTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnJndiTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnJndiTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnJndiTopic",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/jndiTopics/{topicName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnJndiTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnJndiTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnJndiTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnMqttRetainCache updates an m q t t retain cache object

  Update an MQTT Retain Cache object. Any attribute missing from the request will be left unchanged.

Using MQTT retained messages allows publishing MQTT clients to indicate that a message must be stored for later delivery to subscribing clients when those subscribing clients add subscriptions matching the retained message's topic. An MQTT Retain Cache processes all retained messages for a Message VPN.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
cacheName|x|x||||
msgVpnName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.11.
*/
func (a *Client) UpdateMsgVpnMqttRetainCache(params *UpdateMsgVpnMqttRetainCacheParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnMqttRetainCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnMqttRetainCacheParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnMqttRetainCache",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttRetainCaches/{cacheName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnMqttRetainCacheReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnMqttRetainCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnMqttRetainCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnMqttSession updates an m q t t session object

  Update an MQTT Session object. Any attribute missing from the request will be left unchanged.

An MQTT Session object is a virtual representation of an MQTT client connection. An MQTT session holds the state of an MQTT client (that is, it is used to contain a client's QoS 0 and QoS 1 subscription sets and any undelivered QoS 1 messages).


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
mqttSessionClientId|x|x||||
mqttSessionVirtualRouter|x|x||||
msgVpnName|x|x||||
owner||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) UpdateMsgVpnMqttSession(params *UpdateMsgVpnMqttSessionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnMqttSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnMqttSessionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnMqttSession",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnMqttSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnMqttSessionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnMqttSessionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnMqttSessionSubscription updates a subscription object

  Update a Subscription object. Any attribute missing from the request will be left unchanged.

An MQTT session contains a client's QoS 0 and QoS 1 subscription sets. On creation, a subscription defaults to QoS 0.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
mqttSessionClientId|x|x||||
mqttSessionVirtualRouter|x|x||||
msgVpnName|x|x||||
subscriptionTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) UpdateMsgVpnMqttSessionSubscription(params *UpdateMsgVpnMqttSessionSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnMqttSessionSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnMqttSessionSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnMqttSessionSubscription",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/mqttSessions/{mqttSessionClientId},{mqttSessionVirtualRouter}/subscriptions/{subscriptionTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnMqttSessionSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnMqttSessionSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnMqttSessionSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnQueue updates a queue object

  Update a Queue object. Any attribute missing from the request will be left unchanged.

A Queue acts as both a destination that clients can publish messages to, and as an endpoint that clients can bind consumers to and consume messages from.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
accessType||||x||
msgVpnName|x|x||||
owner||||x||
permission||||x||
queueName|x|x||||
respectMsgPriorityEnabled||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnQueue(params *UpdateMsgVpnQueueParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnQueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnQueueParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnQueue",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/queues/{queueName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnQueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnQueueOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnQueueDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnQueueTemplate updates a queue template object

  Update a Queue Template object. Any attribute missing from the request will be left unchanged.

A Queue Template provides a mechanism for specifying the initial state for client created queues.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
queueTemplateName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) UpdateMsgVpnQueueTemplate(params *UpdateMsgVpnQueueTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnQueueTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnQueueTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnQueueTemplate",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/queueTemplates/{queueTemplateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnQueueTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnQueueTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnQueueTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnReplayLog updates a replay log object

  Update a Replay Log object. Any attribute missing from the request will be left unchanged.

When the Message Replay feature is enabled, message brokers store persistent messages in a Replay Log. These messages are kept until the log is full, after which the oldest messages are removed to free up space for new messages.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
replayLogName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.10.
*/
func (a *Client) UpdateMsgVpnReplayLog(params *UpdateMsgVpnReplayLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnReplayLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnReplayLogParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnReplayLog",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/replayLogs/{replayLogName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnReplayLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnReplayLogOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnReplayLogDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnReplicatedTopic updates a replicated topic object

  Update a Replicated Topic object. Any attribute missing from the request will be left unchanged.

To indicate which messages should be replicated between the active and standby site, a Replicated Topic subscription must be configured on a Message VPN. If a published message matches both a replicated topic and an endpoint on the active site, then the message is replicated to the standby site.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
replicatedTopic|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) UpdateMsgVpnReplicatedTopic(params *UpdateMsgVpnReplicatedTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnReplicatedTopicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnReplicatedTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnReplicatedTopic",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/replicatedTopics/{replicatedTopic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnReplicatedTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnReplicatedTopicOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnReplicatedTopicDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnRestDeliveryPoint updates a r e s t delivery point object

  Update a REST Delivery Point object. Any attribute missing from the request will be left unchanged.

A REST Delivery Point manages delivery of messages from queues to a named list of REST Consumers.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
clientProfileName||||x||
msgVpnName|x|x||||
restDeliveryPointName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnRestDeliveryPoint(params *UpdateMsgVpnRestDeliveryPointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnRestDeliveryPointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnRestDeliveryPointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnRestDeliveryPoint",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnRestDeliveryPointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnRestDeliveryPointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnRestDeliveryPointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnRestDeliveryPointQueueBinding updates a queue binding object

  Update a Queue Binding object. Any attribute missing from the request will be left unchanged.

A Queue Binding for a REST Delivery Point attracts messages to be delivered to REST consumers. If the queue does not exist it can be created subsequently, and once the queue is operational the broker performs the queue binding. Removing the queue binding does not delete the queue itself. Similarly, removing the queue does not remove the queue binding, which fails until the queue is recreated or the queue binding is deleted.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
queueBindingName|x|x||||
restDeliveryPointName|x|x||||



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnRestDeliveryPointQueueBinding(params *UpdateMsgVpnRestDeliveryPointQueueBindingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnRestDeliveryPointQueueBindingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnRestDeliveryPointQueueBindingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnRestDeliveryPointQueueBinding",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/queueBindings/{queueBindingName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnRestDeliveryPointQueueBindingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnRestDeliveryPointQueueBindingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnRestDeliveryPointQueueBindingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnRestDeliveryPointRestConsumer updates a r e s t consumer object

  Update a REST Consumer object. Any attribute missing from the request will be left unchanged.

REST Consumer objects establish HTTP connectivity to REST consumer applications who wish to receive messages from a broker.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
authenticationClientCertContent|||x|x||x
authenticationClientCertPassword|||x|x||
authenticationHttpBasicPassword|||x|x||x
authenticationHttpBasicUsername||||x||
authenticationHttpHeaderValue|||x|||x
authenticationOauthClientId||||x||
authenticationOauthClientScope||||x||
authenticationOauthClientSecret|||x|x||x
authenticationOauthClientTokenEndpoint||||x||
authenticationOauthJwtSecretKey|||x|x||x
authenticationOauthJwtTokenEndpoint||||x||
authenticationScheme||||x||
msgVpnName|x|x||||
outgoingConnectionCount||||x||
remoteHost||||x||
remotePort||||x||
restConsumerName|x|x||||
restDeliveryPointName|x|x||||
tlsCipherSuiteList||||x||
tlsEnabled||||x||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
MsgVpnRestDeliveryPointRestConsumer|authenticationClientCertPassword|authenticationClientCertContent|
MsgVpnRestDeliveryPointRestConsumer|authenticationHttpBasicPassword|authenticationHttpBasicUsername|
MsgVpnRestDeliveryPointRestConsumer|authenticationHttpBasicUsername|authenticationHttpBasicPassword|
MsgVpnRestDeliveryPointRestConsumer|remotePort|tlsEnabled|
MsgVpnRestDeliveryPointRestConsumer|tlsEnabled|remotePort|



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.0.
*/
func (a *Client) UpdateMsgVpnRestDeliveryPointRestConsumer(params *UpdateMsgVpnRestDeliveryPointRestConsumerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnRestDeliveryPointRestConsumerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnRestDeliveryPointRestConsumerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnRestDeliveryPointRestConsumer",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/restDeliveryPoints/{restDeliveryPointName}/restConsumers/{restConsumerName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnRestDeliveryPointRestConsumerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnRestDeliveryPointRestConsumerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnRestDeliveryPointRestConsumerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnTopicEndpoint updates a topic endpoint object

  Update a Topic Endpoint object. Any attribute missing from the request will be left unchanged.

A Topic Endpoint attracts messages published to a topic for which the Topic Endpoint has a matching topic subscription. The topic subscription for the Topic Endpoint is specified in the client request to bind a Flow to that Topic Endpoint. Queues are significantly more flexible than Topic Endpoints and are the recommended approach for most applications. The use of Topic Endpoints should be restricted to JMS applications.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
accessType||||x||
msgVpnName|x|x||||
owner||||x||
permission||||x||
respectMsgPriorityEnabled||||x||
topicEndpointName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.1.
*/
func (a *Client) UpdateMsgVpnTopicEndpoint(params *UpdateMsgVpnTopicEndpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnTopicEndpointOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnTopicEndpointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnTopicEndpoint",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpoints/{topicEndpointName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnTopicEndpointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnTopicEndpointOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnTopicEndpointDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateMsgVpnTopicEndpointTemplate updates a topic endpoint template object

  Update a Topic Endpoint Template object. Any attribute missing from the request will be left unchanged.

A Topic Endpoint Template provides a mechanism for specifying the initial state for client created topic endpoints.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
msgVpnName|x|x||||
topicEndpointTemplateName|x|x||||



The following attributes in the request may only be provided in certain combinations with other attributes:


Class|Attribute|Requires|Conflicts
:---|:---|:---|:---
EventThreshold|clearPercent|setPercent|clearValue, setValue
EventThreshold|clearValue|setValue|clearPercent, setPercent
EventThreshold|setPercent|clearPercent|clearValue, setValue
EventThreshold|setValue|clearValue|clearPercent, setPercent



A SEMP client authorized with a minimum access scope/level of "vpn/read-write" is required to perform this operation.

This has been available since 2.14.
*/
func (a *Client) UpdateMsgVpnTopicEndpointTemplate(params *UpdateMsgVpnTopicEndpointTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateMsgVpnTopicEndpointTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMsgVpnTopicEndpointTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateMsgVpnTopicEndpointTemplate",
		Method:             "PATCH",
		PathPattern:        "/msgVpns/{msgVpnName}/topicEndpointTemplates/{topicEndpointTemplateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMsgVpnTopicEndpointTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateMsgVpnTopicEndpointTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateMsgVpnTopicEndpointTemplateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateVirtualHostname updates a virtual hostname object

  Update a Virtual Hostname object. Any attribute missing from the request will be left unchanged.

A Virtual Hostname is a provisioned object on a message broker that contains a Virtual Hostname to Message VPN mapping.

Clients which connect to a global (as opposed to per Message VPN) port and provides this hostname will be directed to its corresponding Message VPN. A case-insentive match is performed on the full client-provided hostname against the configured virtual-hostname.

This mechanism is only supported for hostnames provided through the Server Name Indication (SNI) extension of TLS.


Attribute|Identifying|Read-Only|Write-Only|Requires-Disable|Deprecated|Opaque
:---|:---:|:---:|:---:|:---:|:---:|:---:
virtualHostname|x|x||||



A SEMP client authorized with a minimum access scope/level of "global/read-write" is required to perform this operation.

This has been available since 2.17.
*/
func (a *Client) UpdateVirtualHostname(params *UpdateVirtualHostnameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateVirtualHostnameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateVirtualHostnameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateVirtualHostname",
		Method:             "PATCH",
		PathPattern:        "/virtualHostnames/{virtualHostname}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateVirtualHostnameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateVirtualHostnameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateVirtualHostnameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
